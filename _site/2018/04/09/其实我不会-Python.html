<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/rss+xml" title="小生境" href="/feed.xml">
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">小生境</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">其实我不会 Python</h1>
    <p class="post-meta">
      <time datetime="2018-04-09T00:00:00+08:00" itemprop="datePublished">
        
        2018-04-09
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>代码写得越多，我越发现其实我不会 Python。</p>

<h3 id="1-metaclass-conflict">1. Metaclass Conflict</h3>

<p>其实在 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 中就了解到元类冲突，本以为像我这样的超凡绝伦的人中龙凤并不会遭遇，只有那些滥用元类的傻逼才会蠢到和又要继承第三方包的类又要 Mixin 自己的元类，听上去就可以把这种工程师开除了，直到我自己扇了自己的脸。</p>

<p>我的需求是实现了一个真·抽象基类，同时继承它的类会自动对其中一个方法添加一个装饰器。</p>

<p>比方说，比方说啊，我们实现一个 TCP 服务基类 <code class="highlighter-rouge">AbsTCPServer</code>，所有继承于此的 <code class="highlighter-rouge">TCPServer</code> 必须实现 <code class="highlighter-rouge">handle_peer</code> 方法，同时打印 <code class="highlighter-rouge">handle_peer</code> 的耗时日志。</p>

<p>那么按照一般的思路很容易就能用 <code class="highlighter-rouge">abc</code> 模块写出来这个抽象基类：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>


<span class="k">class</span> <span class="nc">AbsTCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>然后实现一个元类 <code class="highlighter-rouge">TictocTCPMeta</code> 包裹 <code class="highlighter-rouge">handle_peer</code> 统计耗时并打印：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>


<span class="k">def</span> <span class="nf">tictoc</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">start_at</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'elapsed time:'</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_at</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">handle_peer</span>


<span class="k">class</span> <span class="nc">TictocTCPMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
</code></pre></div></div>

<p>然后 Mixin，高潮来了，元类冲突！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="o">...</span>

<span class="c"># TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases</span>
</code></pre></div></div>

<p>解决方案得想办法让这个抽象基类看上去只有一个元类，所以有两个方案：</p>

<p>1) 让 <code class="highlighter-rouge">TictocTCPMeta</code> 继承自 `AbsTCPServer，这样两个元类有一个相同的基元类；</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TictocTCPMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>丑陋但是行得通。</p>

<p>2) Mixin 一个新的元类 <code class="highlighter-rouge">TictocHandlePeerAbsMeta</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TictocHandlePeerAbsMeta</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">TictocHandlePeerAbsMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>方案二比方案一稍好一点，但是两种方案都很扭曲。不过自从 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 之后我们有了更加有力的武器：<code class="highlighter-rouge">__init_subclass__</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AbsTCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">handle_peer</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">handle_peer</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>有个细节是我们不必再使用 <code class="highlighter-rouge">cls.__dict__['handle_peer']</code> 之类的代码来防止触发描述符协议，在 Python3- 中函数的描述符协议会导致 <code class="highlighter-rouge">cls.handle_peer</code> 返回一个 <code class="highlighter-rouge">Bound Method</code>，而在 Python3+ 中不再有这玩意儿。</p>

<p>同时 <code class="highlighter-rouge">__init_subclass__</code> 只在 Python3.6 之后才能使用，所以如果需要兼容 3.5- 可能还不得不吃一口元类的屎。</p>

<h3 id="2-namedtuple">2. NamedTuple</h3>

<blockquote>
  <p>No, I’m not talking about <code class="highlighter-rouge">collections.namedtuple</code>!</p>
</blockquote>

<p>在 <a href="https://www.python.org/dev/peps/pep-0484/">PEP484</a> 之后我们在 <code class="highlighter-rouge">typing</code> 模块中有个一个 <code class="highlighter-rouge">NamedTuple</code> 用来专门为 <code class="highlighter-rouge">collections.namedtuple</code> 中的各个字段声明类型。</p>

<p>一开始 <code class="highlighter-rouge">typing.NamedTuple</code> 还基本和 <code class="highlighter-rouge">collections.namedtuple</code> 等价，然而在 Python3.6.1 之后我们居然可以为 <code class="highlighter-rouge">typing.NamedTuple</code> 定义字段默认值、方法和文档字符串，这就一下扩展了 <code class="highlighter-rouge">typing.NamedTuple</code> 的使用场景了，用 DDD 的话说就是，这是一个如假包换的值对象 (Value Object) 而不是实体 (Entity)。</p>

<p>日常使用 <code class="highlighter-rouge">typing.NamedTuple</code> 本来是很愉快了，直到我再次意识到这玩意根本就不是一个正常的类。</p>

<p>我的需求是定义个 <code class="highlighter-rouge">Jsonizable</code> Mixin，让 <code class="highlighter-rouge">typing.NamedTuple</code> 拥有一个简单<del>普世</del>的 <code class="highlighter-rouge">to_json</code> 方法输出为 <code class="highlighter-rouge">dict</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Jsonizable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>
</code></pre></div></div>

<p>然而在 Mixin 之后发现 <code class="highlighter-rouge">to_json</code> 完全不存在：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>


<span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="n">Namedtuple</span><span class="p">,</span> <span class="n">Jsonizable</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>


<span class="n">value</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
<span class="c"># AttributeError: 'Value' object has no attribute 'to_json'</span>
</code></pre></div></div>

<p>毫无疑问我对 <code class="highlighter-rouge">typing.NamedTuple</code> 做了太多的假设，实际上从<a href="https://github.com/python/cpython/blob/3.6/Lib/typing.py#L2106">源码</a>来看，<code class="highlighter-rouge">typing.NamedTuple</code> 依然是调用 <code class="highlighter-rouge">collections.namedtuple</code> (废话)，然而众所周知 <code class="highlighter-rouge">collections.namedtuple</code> 的<a href="https://github.com/python/cpython/blob/master/Lib/collections/__init__.py#L397">实现</a>是 <code class="highlighter-rouge">exec</code> 大法，所以我尝试注入的 Mixin 无效是正常的。</p>

<p>使用 Mixin 的好处是某个继承了 <code class="highlighter-rouge">Jsonizable</code> 的基类、它派生出的子类都拥有了 <code class="highlighter-rouge">to_json</code> 方法，但是既然继承这条路走不通，我只能用装饰器 workaround：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jsonizable</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="n">namedtuple</span><span class="o">.</span><span class="n">to_json</span> <span class="o">=</span> <span class="n">to_json</span>
    <span class="k">return</span> <span class="n">namedtuple</span>


<span class="nd">@jsonizable</span>
<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p>虽然能够正常工作，但是对于所有的 <code class="highlighter-rouge">typing.NamedTuple</code> 我都必须手动装饰一番，略蛋疼。</p>

<p>那么这时候不如回滚到 Python2.7 的解决方案：使用 <code class="highlighter-rouge">collections.namedtuple</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>


<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">'Value'</span><span class="p">,</span> <span class="s">'head, tail'</span><span class="p">),</span> <span class="n">Jsonizable</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>然而这会让你丧失类型标注和默认值的好处，如果你早就受够了这种老式写法，你一定会爱上黑魔法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTupleMeta</span>


<span class="k">class</span> <span class="nc">NamedTupleMixinMeta</span><span class="p">(</span><span class="n">NamedTupleMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namedtuple</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">klass</span><span class="p">(</span><span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">):</span>
            <span class="o">...</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">typename</span>
        <span class="k">return</span> <span class="n">klass</span>


<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">Jsonizable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">NamedTupleMixinMeta</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p>我知道 <code class="highlighter-rouge">__new__</code> 里面的类定义可以用 <code class="highlighter-rouge">type</code> 函数，但是我认为这样写能够带来更好的可读性，耶~</p>

<p>然而如果你在使用 Python3.7 那么你不妨直接使用 <a href="https://www.python.org/dev/peps/pep-0557/">PEP557</a> 的成果 <code class="highlighter-rouge">dataclass</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">Jsonizable</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dataclass</code> 不仅让我们的值对象真正成为一个正常的类（意味着 Mixin、special methods），而且还提供了一堆诸如 <code class="highlighter-rouge">__post_init__</code> 之类的 hook，感觉 DDD 在朝我们张开双臂 say hello :D</p>

<h3 id="3-staticmethod">3. staticmethod</h3>

<p>静态方法是很少被使用的，在 <em>Fluent Python</em> 一书中（如果不是这本那就是其他什么书）表达出用 <code class="highlighter-rouge">staticmethod</code> 不如在顶层定义函数，我表示认同，除了在极个别的时候，比如我在 Django Class-based view 中想定义 validator，这时候如果你有若干个不相干的 View class 在同个 Python 模块内，与其把 validator 函数定义为顶层函数、不如定义在相关的 View class 内定义为 <code class="highlighter-rouge">staticmethod</code>。</p>

<p>翻译成代码就是，定义在顶层空间的函数 validator：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">model_index_post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
    <span class="o">...</span>


<span class="nd">@model_index_post_validator</span>
<span class="k">def</span> <span class="nf">model_index_post_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>不如定义在 View class 字典空间的 <code class="highlighter-rouge">staticmethod</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.views</span> <span class="kn">import</span> <span class="n">View</span>


<span class="k">class</span> <span class="nc">ModelIndex</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@post_validator</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>你会发现使用 <code class="highlighter-rouge">staticmethod</code> + <code class="highlighter-rouge">Class-based view</code> 把很多变量名隐藏在各个的 namespace 之下，这就很美好了。</p>

<p>但是 oops，上面那段代码居然不能运行？报了一个奇怪的错：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TypeError: <span class="s1">'staticmethod'</span> object is not callable
</code></pre></div></div>

<p>回想一下 staticmethod 的本质：<a href="https://docs.python.org/2/howto/descriptor.html#static-methods-and-class-methods">描述符</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">:</span>
    <span class="s">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
</code></pre></div></div>

<p>只要理解了上面的 Pure Python <code class="highlighter-rouge">staticmethod</code> 就知道报错在说啥了，<code class="highlighter-rouge">@staticmethod</code> 返回的对象是一个实现了描述符协议的实例，它没有实现 <code class="highlighter-rouge">__call__</code> 方法所以直接拿去套装饰器报错 <code class="highlighter-rouge">not callable</code> 合情合理。</p>

<p>那么我们可以自己实现一下静态方法，只要加上 <code class="highlighter-rouge">__call__</code> 就足够了。但是其实这个地方压根不需要静态方法，因为这个方法直接在类级别的 namespace 被调用，根本就不会触发描述符协议，所以正确的做法是：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ModelIndex</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@post_validator</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<h3 id="31-classmethod">3.1 classmethod</h3>

<p>作为 <code class="highlighter-rouge">staticmethod</code> 的姊妹篇还是好心好意说一下与 <code class="highlighter-rouge">classmethod</code> 相关的奇怪问题。</p>

<p>大家对实例属性 <code class="highlighter-rouge">property</code> 都已经非常熟悉了，但是现在我的需求是定义类属性，它看起来大概是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@property</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># &lt;class '__main__.A'&gt;</span>
</code></pre></div></div>

<p>毫无疑问 <code class="highlighter-rouge">classmethod</code> 是不能满足我们需求的，但是一旦理解了其中描述符做的事情、实现起来也非常容易：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">classproperty</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">owner</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># output: &lt;class '__main__.A'&gt;</span>
</code></pre></div></div>

<p>就是这样。</p>

<h3 id="4-遍历子类">4. 遍历子类</h3>

<p>遍历子类本应该是个简单的事情，但是不知道为什么它变得很复杂。</p>

<p>在实际运用的时候我们的需求可能是需要注册 (register) 一些有特定实现的子类，然后之后通过依赖注入的方式使用这些子类。比如 Kubernetes 网络插件系统毫无疑问就是这样做的。</p>

<p>但是我发现我对注册这件事情特别反感：“继承已经是很 explicit 的声明了为什么还需要再声明一次 register？”</p>

<p>所以这就是我要做的事情：能够直接从基类访问其子类。</p>

<p>首先我们从新式类的 <code class="highlighter-rouge">__subclasses__</code> 开始，主要问题是它只返回一级子类，所以多级继承树的情况下扑街。所以我们定义一个 Mixin 可以递归调用 <code class="highlighter-rouge">__subclasses__</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubClassesMixin</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deep_subclasses</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subclass</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
            <span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subclass</span><span class="p">)</span>
            <span class="n">subclasses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="o">.</span><span class="n">__func__</span><span class="p">(</span><span class="n">subclass</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subclasses</span>
</code></pre></div></div>

<p>这样的好处是所有派生出来的子类也都有了这个神奇的 <code class="highlighter-rouge">deep_subclasses</code> 方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">SubClassesMixin</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="p">())</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="p">())</span>
<span class="c"># [&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
</code></pre></div></div>

<p>然而这个 Mixin 的缺点是你每次调用都必须递归一次，性能不优雅；但是如果你缓存结果的话，如果运行时又派生新的类那么之后的调用结果都扑街了。</p>

<p>幸好在 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 中我们有了神奇的 hook <code class="highlighter-rouge">__init_subclass__</code>，那么事情一下就变得更加愉快了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
</code></pre></div></div>

<p>然而不像继承，派生的子类都不具有神奇的 <code class="highlighter-rouge">subclasses</code> 属性。我们希望的代码是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
</code></pre></div></div>

<p>如果每个子类都有一个相同的 <code class="highlighter-rouge">__init_subclass__</code> 方法，那么问题就迎刃而解了。<code class="highlighter-rouge">__init_subclass__</code> 和元类都适合干这种事情，我们就拿 <code class="highlighter-rouge">__init_subclass__</code> 来做好了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span>
            <span class="n">__class__</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="o">.</span><span class="n">__func__</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># []</span>
</code></pre></div></div>

<p>停！<code class="highlighter-rouge">B.subclasses</code> 打印出来的居然是空列表，这是怎么回事？</p>

<p>实际上这是由于 <code class="highlighter-rouge">__class__</code> 这个魔法变量总是绑定定义这个函数时的类、而不是实际运行时所在的类。这里导致了两个问题：</p>

<ol>
  <li>所有的 <code class="highlighter-rouge">__class__.subclasses</code> 实际上都是给同一个列表塞东西</li>
  <li>这个问题非常隐含，因为 <code class="highlighter-rouge">super()</code> 背后做的事情其实是 <code class="highlighter-rouge">super(__class__)</code>，所以你会看到你的所有 <code class="highlighter-rouge">super().__init_subclass__</code> 其实都查到的是 <code class="highlighter-rouge">object.__init_subclass__</code>。</li>
</ol>

<p>既然如此，那么我们用闭包把每个 <code class="highlighter-rouge">__init_subclass__</code> 方法所在的类扔到 <code class="highlighter-rouge">__globals__</code> 中：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubclassMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">class_encloser</span><span class="p">(</span><span class="n">im_class</span><span class="p">):</span>
            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
                <span class="n">im_class</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">im_class</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">__init_subclass__</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">SubclassMeta</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>这下终于一切按照我们预想地进行了。</p>

<p>不想用元类而偏爱 <code class="highlighter-rouge">__init_subclass__</code> 也没问题，主要问题是为了复用代码你必须把 <code class="highlighter-rouge">__init_subclass__</code> 扔到一个装饰器中，感觉这复杂度还不如元类呢：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">subclasses</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">class_encloser</span><span class="p">(</span><span class="n">im_class</span><span class="p">):</span>
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
            <span class="n">im_class</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">im_class</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">__init_subclass__</span>

    <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cls</span>


<span class="nd">@subclasses</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.C'&gt;]</span>
</code></pre></div></div>

<p>但是不要忘了，<code class="highlighter-rouge">__init_subclass__</code> 最大的好处是避免元类冲突，但是从目前来看在某些场景下可能会丧失简洁性。</p>

<hr />

<h3 id="5-classproperty-with-setter">5. classproperty with setter</h3>

<p><a href="https://github.com/junplus">@Jun</a> 针对 <code class="highlighter-rouge">classproperty</code> 提出了一个尖锐的问题：如何为 <code class="highlighter-rouge">classproperty</code> 设置 setter?</p>

<p>它的 API 看起来应该是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">'_a'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@a.setter</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>嗯，看似非常简单，实际上，嘿嘿。</p>

<h4 id="51-__set__">5.1 <code class="highlighter-rouge">__set__</code></h4>

<p>如果我们在 3.1 的基础上加上 <code class="highlighter-rouge">__set__</code> 呢：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">classproperty</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">NotImplementedError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setter_f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span> <span class="o">=</span> <span class="n">setter_f</span>
</code></pre></div></div>

<p>然而，并不能 work。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># None</span>
<span class="n">A</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># 1</span>
</code></pre></div></div>

<p>发现 <code class="highlighter-rouge">A.a = 1</code> 直接设置到 <code class="highlighter-rouge">A.__dict__['a']</code> 里去了，简直出乎意料，说好的数据描述符呢？</p>

<h4 id="52-descriptor-protocol">5.2 Descriptor Protocol</h4>

<p>重新看一下 <code class="highlighter-rouge">3.1</code> 的 <code class="highlighter-rouge">classproperty</code> 代码，发现，我擦，为什么这也行？</p>

<p><code class="highlighter-rouge">3.1</code> 的代码中，描述符定义在 <code class="highlighter-rouge">A.__dict__</code> 中，而我们居然在 <code class="highlighter-rouge">A.a</code> 就调用了描述符协议？我们是不是错过了什么细节？什么时候自己字典空间里的描述符可以直接触发描述符协议了？</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Descr</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">owner</span>


<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">Descr</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="c"># &lt;__main__.Descr object at 0x1102b4f60&gt;</span>
</code></pre></div></div>

<p>可以看到直接在类实例的字典空间设置描述符并没有触发描述符协议。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Descr</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">owner</span>


<span class="n">A</span><span class="o">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">Descr</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
<span class="c"># &lt;class '__main__.A'&gt;</span>
</code></pre></div></div>

<p>然而直接在类的字典空间设置描述符居然能够触发！</p>

<p>感觉我的 Python 又白学了。。</p>

<p><a href="https://docs.python.org/3.6/howto/descriptor.html#invoking-descriptors">文档</a>对这件事情的记录是非常含糊不清的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For objects, the machinery is in object.__getattribute__() which transforms b.x into type(b).__dict__['x'].__get__(b, type(b)). 
For classes, the machinery is in type.__getattribute__() which transforms B.x into B.__dict__['x'].__get__(None, B).
</code></pre></div></div>

<p>而且最关键的是下面这句话：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object.__getattribute__() and type.__getattribute__() make different calls to __get__().
</code></pre></div></div>

<p>哇哦，所以在类上调用描述符和在类实例上调用描述符完全是两个协议！！！</p>

<p>直接上源码好了，首先是类实例的描述符协议：<code class="highlighter-rouge">object.__getattribute__</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://github.com/python/cpython/blob/3.6/Objects/object.c#L1036
</span><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyObject_GenericGetAttrWithDict</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">dict</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">descr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">Py_ssize_t</span> <span class="n">dictoffset</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">dictptr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">name</span><span class="p">)){</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                     <span class="s">"attribute name must be string, not '%.200s'"</span><span class="p">,</span>
                     <span class="n">name</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">descr</span> <span class="o">=</span> <span class="n">_PyType_Lookup</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="n">f</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">descr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">descr</span><span class="p">);</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">descr</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_descr_get</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">PyDescr_IsData</span><span class="p">(</span><span class="n">descr</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Inline _PyObject_GetDictPtr */</span>
        <span class="n">dictoffset</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_dictoffset</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dictoffset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dictoffset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_ssize_t</span> <span class="n">tsize</span><span class="p">;</span>
                <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

                <span class="n">tsize</span> <span class="o">=</span> <span class="p">((</span><span class="n">PyVarObject</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_size</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tsize</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">tsize</span> <span class="o">=</span> <span class="o">-</span><span class="n">tsize</span><span class="p">;</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">_PyObject_VAR_SIZE</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">tsize</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PY_SSIZE_T_MAX</span><span class="p">);</span>

                <span class="n">dictoffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Py_ssize_t</span><span class="p">)</span><span class="n">size</span><span class="p">;</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">dictoffset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">dictoffset</span> <span class="o">%</span> <span class="n">SIZEOF_VOID_P</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">dictptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">**</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span> <span class="o">+</span> <span class="n">dictoffset</span><span class="p">);</span>
            <span class="n">dict</span> <span class="o">=</span> <span class="o">*</span><span class="n">dictptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dict</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">descr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">descr</span><span class="p">;</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                 <span class="s">"'%.50s' object has no attribute '%U'"</span><span class="p">,</span>
                 <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="nl">done:</span>
    <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">descr</span><span class="p">);</span>
    <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到逻辑是：</p>

<ol>
  <li>在实例的构造类及其基类树上搜索，若搜索到非数据描述符则触发协议返回；</li>
  <li>否则直接在类实例的 <code class="highlighter-rouge">__dict__</code> 中搜索，若搜索到则原样返回；</li>
  <li>否则如果在 <code class="highlighter-rouge">1</code> 中搜索到非数据描述符则触发协议返回；</li>
  <li>否则抛 <code class="highlighter-rouge">AttributeError</code></li>
</ol>

<p>嗯，和我理解的描述符协议完全一样，</p>

<p>但是类的描述符协议：<code class="highlighter-rouge">type.__getattribute__</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://github.com/python/cpython/blob/master/Objects/typeobject.c#L3135
</span><span class="cm">/* This is similar to PyObject_GenericGetAttr(),
   but uses _PyType_Lookup() instead of just looking in type-&gt;tp_dict. */</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">type_getattro</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">metatype</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">meta_attribute</span><span class="p">,</span> <span class="o">*</span><span class="n">attribute</span><span class="p">;</span>
    <span class="n">descrgetfunc</span> <span class="n">meta_get</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyUnicode_Check</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                     <span class="s">"attribute name must be string, not '%.200s'"</span><span class="p">,</span>
                     <span class="n">name</span><span class="o">-&gt;</span><span class="n">ob_type</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Initialize this type (we'll assume the metatype is initialized) */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_dict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyType_Ready</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* No readable descriptor found yet */</span>
    <span class="n">meta_get</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Look for the attribute in the metatype */</span>
    <span class="n">meta_attribute</span> <span class="o">=</span> <span class="n">_PyType_Lookup</span><span class="p">(</span><span class="n">metatype</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">meta_attribute</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">meta_get</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_descr_get</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">meta_get</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">PyDescr_IsData</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* Data descriptors implement tp_descr_set to intercept
             * writes. Assume the attribute is not overridden in
             * type's tp_dict (and bases): call the descriptor now.
             */</span>
            <span class="k">return</span> <span class="n">meta_get</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">metatype</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* No data descriptor found on metatype. Look in tp_dict of this
     * type and its bases */</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">_PyType_Lookup</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">attribute</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Implement descriptor functionality, if any */</span>
        <span class="n">descrgetfunc</span> <span class="n">local_get</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tp_descr_get</span><span class="p">;</span>

        <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">local_get</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* NULL 2nd argument indicates the descriptor was
             * found on the target object itself (or a base)  */</span>
            <span class="k">return</span> <span class="n">local_get</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span>
                             <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">attribute</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">attribute</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* No attribute found in local __dict__ (or bases): use the
     * descriptor from the metatype, if any */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meta_get</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">meta_get</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">,</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">,</span>
                       <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">metatype</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">meta_attribute</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* If an ordinary attribute was found on the metatype, return it now */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">meta_attribute</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">meta_attribute</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Give up */</span>
    <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_AttributeError</span><span class="p">,</span>
                 <span class="s">"type object '%.50s' has no attribute '%U'"</span><span class="p">,</span>
                 <span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>梳理结果如下：</p>

<ol>
  <li>在元类树上搜索属性，若是个数据描述符则触发协议返回；</li>
  <li>否则在类的基类树（含自身）及其元类树上搜索，若搜索到描述符则触发协议返回、若不是描述符则原样返回；</li>
  <li>否则抛 <code class="highlighter-rouge">AttributeError</code></li>
</ol>

<p>哇，和类实例的描述符协议完全不一样！！！高潮在于居然会在基类树（含自身）上搜索描述符，所以这也解释了为什么直接在类字典空间设置描述符居然能够触发描述符协议。</p>

<p>同样梳理一遍 <a href="https://github.com/python/cpython/blob/3.6/Objects/object.c#L1130"><code class="highlighter-rouge">object.__setattr__</code></a> 与 <a href="https://github.com/python/cpython/blob/master/Objects/typeobject.c#L3217"><code class="highlighter-rouge">type.__setattr__</code></a> 就能发现，<code class="highlighter-rouge">type.__setattr__</code> 却没有像 <code class="highlighter-rouge">type.__getattribute__</code> 那样去搜索基类树（含自身）上的描述符，所以像 <code class="highlighter-rouge">5.1</code> 那样在类字典空间中设置数据描述符并不能正确触发协议。</p>

<p>(妈的为什么文档压根没有写这个？会死人的知不知道？</p>

<h4 id="53-classproperty-in-metaclass">5.3 classproperty in metaclass</h4>

<p>重新梳理了描述符协议之后再来用元类实现一遍：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">classproperty</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getter_f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">getter_f</span> <span class="o">=</span> <span class="n">getter_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">setter_f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setter_f</span> <span class="o">=</span> <span class="n">setter_f</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">ClsPptMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">namespace</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">classproperty</span><span class="p">):</span>

                <span class="k">class</span> <span class="nc">Descr</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">getter_f</span><span class="o">=</span><span class="n">meth</span><span class="o">.</span><span class="n">getter_f</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">getter_f</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

                    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">setter_f</span><span class="o">=</span><span class="n">meth</span><span class="o">.</span><span class="n">setter_f</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">setter_f</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">Descr</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ClsPptMeta</span><span class="p">):</span>
    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">'_a'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@a.setter</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>一切顺利。</p>

<p>同时要指出来的是，由于 <code class="highlighter-rouge">type.__getattribute__</code> 也搜索了基类树，所以如果只是希望实现一个只读的 <code class="highlighter-rouge">classproperty</code> 的话也可以直接继承就好了。</p>

<p>更加要指出来的是，由于 <code class="highlighter-rouge">type.__getattribute__</code> 也搜索了基类树上的元类树，所以我们可以继承一个构造了如上元类的基类。</p>

<h4 id="54-不要元类">5.4 不要元类？</h4>

<p>然而我们依然没有达到我们的目标。我们希望的目标中是只暴露装饰器语法，而我们现在声明了元类，不美好。</p>

<p>从几个思路去看：</p>

<p>1) 想办法动态 patch 元类</p>

<p>然而行不通。我们说的可是要修改 <code class="highlighter-rouge">cls.__class__</code>，Guido 听了都想打人。</p>

<p>2) 想办法动态 patch 基类</p>

<p>然而行不通。我们说的可是要修改 <code class="highlighter-rouge">cls.__bases__</code>，Guido 在 Python2.2 上市后听了都想打人。</p>

<p>3) 想办法生成一个新的类覆盖 <code class="highlighter-rouge">__main__</code> 字典空间</p>

<p>然而行不通。我们说的可是在创建一个类的时候通过一个 hook （眼下似乎也只有 <code class="highlighter-rouge">__set_name__</code> 可用）修改 <code class="highlighter-rouge">globals()</code>，就算你一时得逞，创建完成这个类的之后又会立刻把你覆盖掉。</p>

<p>所以真的没有办法了吗？</p>

<p>反正我是没辙啦，耶！</p>

<hr />

<p>好吧，这就是最近写基础服务遇到的奇怪的语言方面的问题。</p>

<p>(其实还有一些奇怪的问题，懒得写了，我要干别的事情了。)</p>

<p>毫无疑问我离 <code class="highlighter-rouge">装逼如风</code> 的境界确实差的太远了，虽然距离我当年此时写 <a href="https://manjusaka.itscoder.com/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/">听说你会 Python</a> 已经过去两年了，但是我对这门语言的敬畏不断加深，从入门都快放弃去写 Golang 了。</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">小生境</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jschwinger23
            
            </li>
            
            <li><a href="mailto:greyschwinger@gmail.com">greyschwinger@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jschwinger23"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jschwinger23</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Live to tell
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
