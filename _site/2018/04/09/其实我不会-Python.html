<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/rss+xml" title="小生境" href="/feed.xml">
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">小生境</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">其实我不会 Python</h1>
    <p class="post-meta">
      <time datetime="2018-04-09T00:00:00+08:00" itemprop="datePublished">
        
        2018-04-09
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>代码写得越多，我越发现其实我不会 Python。</p>

<h3 id="1-metaclass-conflict">1. Metaclass Conflict</h3>

<p>其实在 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 中就了解到元类冲突，本以为像我这样的超凡绝伦的人中龙凤并不会遭遇，只有那些滥用元类的傻逼才会蠢到和又要继承第三方包的类又要 Mixin 自己的元类，听上去就可以把这种工程师开除了，直到我自己扇了自己的脸。</p>

<p>我的需求是实现了一个真·抽象基类，同时继承它的类会自动对其中一个方法添加一个装饰器。</p>

<p>比方说，比方说啊，我们实现一个 TCP 服务基类 <code class="highlighter-rouge">AbsTCPServer</code>，所有继承于此的 <code class="highlighter-rouge">TCPServer</code> 必须实现 <code class="highlighter-rouge">handle_peer</code> 方法，同时打印 <code class="highlighter-rouge">handle_peer</code> 的耗时日志。</p>

<p>那么按照一般的思路很容易就能用 <code class="highlighter-rouge">abc</code> 模块写出来这个抽象基类：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>


<span class="k">class</span> <span class="nc">AbsTCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>然后实现一个元类 <code class="highlighter-rouge">TictocTCPMeta</code> 包裹 <code class="highlighter-rouge">handle_peer</code> 统计耗时并打印：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>


<span class="k">def</span> <span class="nf">tictoc</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">start_at</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'elapsed time:'</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_at</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">handle_peer</span>


<span class="k">class</span> <span class="nc">TictocTCPMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
</code></pre></div></div>

<p>然后 Mixin，高潮来了，元类冲突！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="o">...</span>

<span class="c"># TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases</span>
</code></pre></div></div>

<p>解决方案得想办法让这个抽象基类看上去只有一个元类，所以有两个方案：</p>

<p>1) 让 <code class="highlighter-rouge">TictocTCPMeta</code> 继承自 `AbsTCPServer，这样两个元类有一个相同的基元类；</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TictocTCPMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">namespace</span><span class="p">[</span><span class="s">'handle_peer'</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>丑陋但是行得通。</p>

<p>2) Mixin 一个新的元类 <code class="highlighter-rouge">TictocHandlePeerAbsMeta</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TictocHandlePeerAbsMeta</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">,</span> <span class="n">TictocTCPMeta</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">TictocHandlePeerAbsMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>方案二比方案一稍好一点，但是两种方案都很扭曲。不过自从 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 之后我们有了更加有力的武器：<code class="highlighter-rouge">__init_subclass__</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AbsTCPServer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">handle_peer</span> <span class="o">=</span> <span class="n">tictoc</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">handle_peer</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">AbsTCPServer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle_peer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>有个细节是我们不必再使用 <code class="highlighter-rouge">cls.__dict__['handle_peer']</code> 之类的代码来防止触发描述符协议，在 Python3- 中函数的描述符协议会导致 <code class="highlighter-rouge">cls.handle_peer</code> 返回一个 <code class="highlighter-rouge">Bound Method</code>，而在 Python3+ 中不再有这玩意儿。</p>

<p>同时 <code class="highlighter-rouge">__init_subclass__</code> 只在 Python3.6 之后才能使用，所以如果需要兼容 3.5- 可能还不得不吃一口元类的屎。</p>

<h3 id="2-namedtuple">2. NamedTuple</h3>

<blockquote>
  <p>No, I’m not talking about <code class="highlighter-rouge">collections.namedtuple</code>!</p>
</blockquote>

<p>在 <a href="https://www.python.org/dev/peps/pep-0484/">PEP484</a> 之后我们在 <code class="highlighter-rouge">typing</code> 模块中有个一个 <code class="highlighter-rouge">NamedTuple</code> 用来专门为 <code class="highlighter-rouge">collections.namedtuple</code> 中的各个字段声明类型。</p>

<p>一开始 <code class="highlighter-rouge">typing.NamedTuple</code> 还基本和 <code class="highlighter-rouge">collections.namedtuple</code> 等价，然而在 Python3.6.1 之后我们居然可以为 <code class="highlighter-rouge">typing.NamedTuple</code> 定义字段默认值、方法和文档字符串，这就一下扩展了 <code class="highlighter-rouge">typing.NamedTuple</code> 的使用场景了，用 DDD 的话说就是，这是一个如假包换的值对象 (Value Object) 而不是实体 (Entity)。</p>

<p>日常使用 <code class="highlighter-rouge">typing.NamedTuple</code> 本来是很愉快了，直到我再次意识到这玩意根本就不是一个正常的类。</p>

<p>我的需求是定义个 <code class="highlighter-rouge">Jsonizable</code> Mixin，让 <code class="highlighter-rouge">typing.NamedTuple</code> 拥有一个简单<del>普世</del>的 <code class="highlighter-rouge">to_json</code> 方法输出为 <code class="highlighter-rouge">dict</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Jsonizable</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>
</code></pre></div></div>

<p>然而在 Mixin 之后发现 <code class="highlighter-rouge">to_json</code> 完全不存在：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTuple</span>


<span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="n">Namedtuple</span><span class="p">,</span> <span class="n">Jsonizable</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>


<span class="n">value</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">to_json</span><span class="p">())</span>
<span class="c"># AttributeError: 'Value' object has no attribute 'to_json'</span>
</code></pre></div></div>

<p>毫无疑问我对 <code class="highlighter-rouge">typing.NamedTuple</code> 做了太多的假设，实际上从<a href="https://github.com/python/cpython/blob/3.6/Lib/typing.py#L2106">源码</a>来看，<code class="highlighter-rouge">typing.NamedTuple</code> 依然是调用 <code class="highlighter-rouge">collections.namedtuple</code> (废话)，然而众所周知 <code class="highlighter-rouge">collections.namedtuple</code> 的<a href="https://github.com/python/cpython/blob/master/Lib/collections/__init__.py#L397">实现</a>是 <code class="highlighter-rouge">exec</code> 大法，所以我尝试注入的 Mixin 无效是正常的。</p>

<p>使用 Mixin 的好处是某个继承了 <code class="highlighter-rouge">Jsonizable</code> 的基类、它派生出的子类都拥有了 <code class="highlighter-rouge">to_json</code> 方法，但是既然继承这条路走不通，我只能用装饰器 workaround：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">jsonizable</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>

    <span class="n">namedtuple</span><span class="o">.</span><span class="n">to_json</span> <span class="o">=</span> <span class="n">to_json</span>
    <span class="k">return</span> <span class="n">namedtuple</span>


<span class="nd">@jsonizable</span>
<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p>虽然能够正常工作，但是对于所有的 <code class="highlighter-rouge">typing.NamedTuple</code> 我都必须手动装饰一番，略蛋疼。</p>

<p>那么这时候不如回滚到 Python2.7 的解决方案：使用 <code class="highlighter-rouge">collections.namedtuple</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>


<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">'Value'</span><span class="p">,</span> <span class="s">'head, tail'</span><span class="p">),</span> <span class="n">Jsonizable</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>然而这会让你丧失类型标注和默认值的好处，如果你早就受够了这种老式写法，你一定会爱上黑魔法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NamedTupleMeta</span>


<span class="k">class</span> <span class="nc">NamedTupleMixinMeta</span><span class="p">(</span><span class="n">NamedTupleMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="n">namedtuple</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">klass</span><span class="p">(</span><span class="o">*</span><span class="n">bases</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">):</span>
            <span class="o">...</span>

        <span class="n">klass</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">typename</span>
        <span class="k">return</span> <span class="n">klass</span>


<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">Jsonizable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">NamedTupleMixinMeta</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p>我知道 <code class="highlighter-rouge">__new__</code> 里面的类定义可以用 <code class="highlighter-rouge">type</code> 函数，但是我认为这样写能够带来更好的可读性，耶~</p>

<p>然而如果你在使用 Python3.7 那么你不妨直接使用 <a href="https://www.python.org/dev/peps/pep-0557/">PEP557</a> 的成果 <code class="highlighter-rouge">dataclass</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Value</span><span class="p">(</span><span class="n">Jsonizable</span><span class="p">):</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">tail</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dataclass</code> 不仅让我们的值对象真正成为一个正常的类（意味着 Mixin、special methods），而且还提供了一堆诸如 <code class="highlighter-rouge">__post_init__</code> 之类的 hook，感觉 DDD 在朝我们张开双臂 say hello :D</p>

<h3 id="3-staticmethod">3. staticmethod</h3>

<p>静态方法是很少被使用的，在 <em>Fluent Python</em> 一书中（如果不是这本那就是其他什么书）表达出用 <code class="highlighter-rouge">staticmethod</code> 不如在顶层定义函数，我表示认同，除了在极个别的时候，比如我在 Django Class-based view 中想定义 validator，这时候如果你有若干个不相干的 View class 在同个 Python 模块内，与其把 validator 函数定义为顶层函数、不如定义在相关的 View class 内定义为 <code class="highlighter-rouge">staticmethod</code>。</p>

<p>翻译成代码就是，定义在顶层空间的函数 validator：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">model_index_post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
    <span class="o">...</span>


<span class="nd">@model_index_post_validator</span>
<span class="k">def</span> <span class="nf">model_index_post_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>不如定义在 View class 字典空间的 <code class="highlighter-rouge">staticmethod</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">django.views</span> <span class="kn">import</span> <span class="n">View</span>


<span class="k">class</span> <span class="nc">ModelIndex</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@post_validator</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<p>你会发现使用 <code class="highlighter-rouge">staticmethod</code> + <code class="highlighter-rouge">Class-based view</code> 把很多变量名隐藏在各个的 namespace 之下，这就很美好了。</p>

<p>但是 oops，上面那段代码居然不能运行？报了一个奇怪的错：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TypeError: <span class="s1">'staticmethod'</span> object is not callable
</code></pre></div></div>

<p>回想一下 staticmethod 的本质：<a href="https://docs.python.org/2/howto/descriptor.html#static-methods-and-class-methods">描述符</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StaticMethod</span><span class="p">:</span>
    <span class="s">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span>
</code></pre></div></div>

<p>只要理解了上面的 Pure Python <code class="highlighter-rouge">staticmethod</code> 就知道报错在说啥了，<code class="highlighter-rouge">@staticmethod</code> 返回的对象是一个实现了描述符协议的实例，它没有实现 <code class="highlighter-rouge">__call__</code> 方法所以直接拿去套装饰器报错 <code class="highlighter-rouge">not callable</code> 合情合理。</p>

<p>那么我们可以自己实现一下静态方法，只要加上 <code class="highlighter-rouge">__call__</code> 就足够了。但是其实这个地方压根不需要静态方法，因为这个方法直接在类级别的 namespace 被调用，根本就不会触发描述符协议，所以正确的做法是：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ModelIndex</span><span class="p">(</span><span class="n">View</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">post_validator</span><span class="p">(</span><span class="n">view_func</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="nd">@post_validator</span>
    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="o">...</span>
</code></pre></div></div>

<h3 id="31-classmethod">3.1 classmethod</h3>

<p>作为 <code class="highlighter-rouge">staticmethod</code> 的姊妹篇还是好心好意说一下与 <code class="highlighter-rouge">classmethod</code> 相关的奇怪问题。</p>

<p>大家对实例属性 <code class="highlighter-rouge">property</code> 都已经非常熟悉了，但是现在我的需求是定义类属性，它看起来大概是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@property</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># &lt;class '__main__.A'&gt;</span>
</code></pre></div></div>

<p>毫无疑问 <code class="highlighter-rouge">classmethod</code> 是不能满足我们需求的，但是一旦理解了其中描述符做的事情、实现起来也非常容易：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ClassProperty</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">owner</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="nd">@ClassProperty</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="c"># output: &lt;class '__main__.A'&gt;</span>
</code></pre></div></div>

<p>或者考虑到类的本质是元类的实例，所以也可以在元类中实现描述符协议来做点事情：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">classproperty</span><span class="p">(</span><span class="n">method_names</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">ClassPropertyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
            <span class="k">class</span> <span class="nc">_class_property</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

                <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">method_names</span><span class="p">:</span>
                <span class="n">namespace</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_class_property</span><span class="p">(</span>
                    <span class="n">namespace</span><span class="p">[</span><span class="n">method_name</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ClassPropertyMeta</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">classproperty</span><span class="p">(</span><span class="s">'a'</span><span class="p">)):</span>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span>
</code></pre></div></div>

<p>就是这样。(我为什么要炫技- -)</p>

<h3 id="4-遍历子类">4. 遍历子类</h3>

<p>遍历子类本应该是个简单的事情，但是不知道为什么它变得很复杂。</p>

<p>在实际运用的时候我们的需求可能是需要注册 (register) 一些有特定实现的子类，然后之后通过依赖注入的方式使用这些子类。比如 Kubernetes 网络插件系统毫无疑问就是这样做的。</p>

<p>但是我发现我对注册这件事情特别反感：“继承已经是很 explicit 的声明了为什么还需要再声明一次 register？”</p>

<p>所以这就是我要做的事情：能够直接从基类访问其子类。</p>

<p>首先我们从新式类的 <code class="highlighter-rouge">__subclasses__</code> 开始，主要问题是它只返回一级子类，所以多级继承树的情况下扑街。所以我们定义一个 Mixin 可以递归调用 <code class="highlighter-rouge">__subclasses__</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubClassesMixin</span><span class="p">:</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deep_subclasses</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subclass</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
            <span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subclass</span><span class="p">)</span>
            <span class="n">subclasses</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="o">.</span><span class="n">__func__</span><span class="p">(</span><span class="n">subclass</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subclasses</span>
</code></pre></div></div>

<p>这样的好处是所有派生出来的子类也都有了这个神奇的 <code class="highlighter-rouge">deep_subclasses</code> 方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">SubClassesMixin</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="p">())</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">deep_subclasses</span><span class="p">())</span>
<span class="c"># [&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
</code></pre></div></div>

<p>然而这个 Mixin 的缺点是你每次调用都必须递归一次，性能不优雅；但是如果你缓存结果的话，如果运行时又派生新的类那么之后的调用结果都扑街了。</p>

<p>幸好在 <a href="https://www.python.org/dev/peps/pep-0487/">PEP487</a> 中我们有了神奇的 hook <code class="highlighter-rouge">__init_subclass__</code>，那么事情一下就变得更加愉快了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
</code></pre></div></div>

<p>然而不像继承，派生的子类都不具有神奇的 <code class="highlighter-rouge">subclasses</code> 属性。我们希望的代码是这样的：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>
</code></pre></div></div>

<p>如果每个子类都有一个相同的 <code class="highlighter-rouge">__init_subclass__</code> 方法，那么问题就迎刃而解了。<code class="highlighter-rouge">__init_subclass__</code> 和元类都适合干这种事情，我们就拿 <code class="highlighter-rouge">__init_subclass__</code> 来做好了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">__class__</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span>
            <span class="n">__class__</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="o">.</span><span class="n">__func__</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># []</span>
</code></pre></div></div>

<p>停！<code class="highlighter-rouge">B.subclasses</code> 打印出来的居然是空列表，这是怎么回事？</p>

<p>实际上这是由于 <code class="highlighter-rouge">__class__</code> 这个魔法变量总是绑定定义这个函数时的类、而不是实际运行时所在的类。这里导致了两个问题：</p>

<ol>
  <li>所有的 <code class="highlighter-rouge">__class__.subclasses</code> 实际上都是给同一个列表塞东西</li>
  <li>这个问题非常隐含，因为 <code class="highlighter-rouge">super()</code> 背后做的事情其实是 <code class="highlighter-rouge">super(__class__)</code>，所以你会看到你的所有 <code class="highlighter-rouge">super().__init_subclass__</code> 其实都查到的是 <code class="highlighter-rouge">object.__init_subclass__</code>。</li>
</ol>

<p>既然如此，那么我们用闭包把每个 <code class="highlighter-rouge">__init_subclass__</code> 方法所在的类扔到 <code class="highlighter-rouge">__globals__</code> 中：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SubclassMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">class_encloser</span><span class="p">(</span><span class="n">im_class</span><span class="p">):</span>
            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
                <span class="n">im_class</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">im_class</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">__init_subclass__</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">SubclassMeta</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>
</code></pre></div></div>

<p>这下终于一切按照我们预想地进行了。</p>

<p>不想用元类而偏爱 <code class="highlighter-rouge">__init_subclass__</code> 也没问题，主要问题是为了复用代码你必须把 <code class="highlighter-rouge">__init_subclass__</code> 扔到一个装饰器中，感觉这复杂度还不如元类呢：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">subclasses</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">class_encloser</span><span class="p">(</span><span class="n">im_class</span><span class="p">):</span>
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
            <span class="n">im_class</span><span class="o">.</span><span class="n">subclasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">im_class</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">__init_subclass__</span>

    <span class="n">cls</span><span class="o">.</span><span class="n">subclasses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cls</span><span class="o">.</span><span class="n">__init_subclass__</span> <span class="o">=</span> <span class="n">class_encloser</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cls</span>


<span class="nd">@subclasses</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;]</span>
<span class="k">print</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">subclasses</span><span class="p">)</span>
<span class="c"># [&lt;class '__main__.C'&gt;]</span>
</code></pre></div></div>

<p>但是不要忘了，<code class="highlighter-rouge">__init_subclass__</code> 最大的好处是避免元类冲突，但是从目前来看在某些场景下可能会丧失简洁性。</p>

<hr />

<p>好吧，这就是最近写基础服务遇到的奇怪的语言方面的问题。</p>

<p>(其实还有一些奇怪的问题，懒得写了，我要干别的事情了。)</p>

<p>毫无疑问我离 <code class="highlighter-rouge">装逼如风</code> 的境界确实差的太远了，虽然距离我当年此时写 <a href="https://manjusaka.itscoder.com/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/">听说你会 Python</a> 已经过去两年了，但是我对这门语言的敬畏不断加深，从入门都快放弃去写 Golang 了。</p>

<p>好的下一篇写写神奇的 Kubernetes，耶。</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">小生境</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jschwinger23
            
            </li>
            
            <li><a href="mailto:greyschwinger@gmail.com">greyschwinger@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jschwinger23"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jschwinger23</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Live to tell
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
