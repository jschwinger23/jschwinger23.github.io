<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/rss+xml" title="小生境" href="/feed.xml">
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">小生境</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Ghost in the Shell</h1>
    <p class="post-meta">
      <time datetime="2018-02-23T00:00:00+08:00" itemprop="datePublished">
        
        2018-02-23
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>Shell programming is a 1950s juke box.  –Larry Wall</p>
</blockquote>

<p>Shell 编程 (以下默认为 Bourne Again Shell) 是有趣的，就连 Larry Wall 大神都如是说。接下来的故事大家都知道了，大神嫌 Shell 可读性太高发明了 Perl 与 Perl6，然后赶上 Web1.0 的顺风车站稳 TIOBE 编程语言排行榜前 10，居然到现在都还没死。我是说 Perl。</p>

<p>我是在 2015 年末才开始开始接触到 Shell，吃了多年狗屎，终于总结出一套日常使用 Shell 批处理文件与文本的套路。所以这篇文章的真实标题其实应该是 <code class="highlighter-rouge">Shell in Daily Use</code> 什么的..</p>

<hr />
<h3 id="1-遍历文件">1. 遍历文件</h3>

<p>遍历文件绝对是让人头疼的一件事情，远远比我想象得复杂。</p>

<h4 id="11-find">1.1 <code class="highlighter-rouge">find</code></h4>

<p>首先是 <code class="highlighter-rouge">find</code> 命令（以下默认为 GNU Findutils，建议 macOS 用户<del>去死</del>运行 <code class="highlighter-rouge">brew install findutils --with-default-names</code>），其中最常用的选项大概是 <code class="highlighter-rouge">-name</code>，比方说递归遍历当前目录下的所有 py 文件然后打印出来：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span>
</code></pre></div></div>

<p>然而不要忘了另外几个同样有用的选项 <code class="highlighter-rouge">-path</code> 与 <code class="highlighter-rouge">-regex</code>，以及它们的 case-ignore 版本 <code class="highlighter-rouge">-iname</code> / <code class="highlighter-rouge">-ipath</code> / <code class="highlighter-rouge">-iregex</code>，比如搜索在 tests 目录下的 py 文件：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-path</span> <span class="s1">'*/tests/*.py'</span>
</code></pre></div></div>

<p>查找所有的名字叫做 folder 的 jpg，不区分大小写：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-iname</span> folder.jpg
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">-regex</code> 时建议通过 <code class="highlighter-rouge">-regextype</code> 选择正则引擎，默认的 <code class="highlighter-rouge">findutils-default</code> 引擎简直可以去死了。比如查找所有的在 <code class="highlighter-rouge">**/test/</code> 或者 <code class="highlighter-rouge">**/test/</code> 之下的 py 文件或者 pyc 文件：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-regex</span> <span class="s1">'.*/tests?/.*\.pyc?'</span>  <span class="nt">-regextype</span> posix-extended
</code></pre></div></div>

<p>查找所有的名字叫做 folder 的 jpg 或者 png，不区分大小写：</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-iregex</span> <span class="s1">'.*folder.\(jpg\|png\)'</span> <span class="nt">-regextype</span> posix-extended
</code></pre></div></div>

<p>特殊字符的转义是相当恶心的，有时候你真的拿捏不准那些字符在哪些模式下是需要转义才能表达特殊含义，比如如上的 <code class="highlighter-rouge">(</code> / <code class="highlighter-rouge">)</code> / <code class="highlighter-rouge">|</code>。</p>

<p>熟练使用 <code class="highlighter-rouge">-regex</code> 可以让你少背很多文档，比如由于 <code class="highlighter-rouge">find</code> 没有 <code class="highlighter-rouge">-exclude</code>，所以排除目录的话你要么用 <code class="highlighter-rouge">-prune</code> 要么用 <code class="highlighter-rouge">-regex</code> 自己撸：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 排除 .git 目录之 prune 党</span>
find <span class="nb">.</span> <span class="nt">-path</span> <span class="s1">'*/.git/*'</span> <span class="nt">-prune</span> <span class="nt">-o</span> <span class="nt">-print</span>

<span class="c"># 排除 .git 目录之 regex 党</span>
find <span class="nb">.</span> <span class="nt">-regex</span> <span class="s1">'./\([^.]\|\.[^g]\|\.g[^i]\|\.gi[^t]\).*'</span> <span class="nt">-regextype</span> posix-extended
</code></pre></div></div>

<p>严格来说，上面的 regex 党的代码并不等价 prune 党，regex 党只是排除了 <code class="highlighter-rouge">./.git/</code>，而 prune 排除了 <code class="highlighter-rouge">./**/.git/</code>；但是因为就算是 <code class="highlighter-rouge">-regextype posix-extended</code> 也不支持惰性 <code class="highlighter-rouge">*</code> 与 <code class="highlighter-rouge">+</code>，更别说环视了，所以这就是我们能做到的最好的程度了。</p>

<p>或者是只遍历到二级子目录：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 遍历二级子目录之 maxdepth 党</span>
find <span class="nb">.</span> <span class="nt">-maxdepth</span> 2

<span class="c"># 遍历二级子目录之 regex 党</span>
find <span class="nb">.</span> <span class="nt">-regex</span> <span class="s1">'./[^/]*/[^/]*'</span>
</code></pre></div></div>

<p>严格来说，上面 regex 党的代码并不等价 prune 党，regex 严格搜索二级子目录，而 maxdepth 搜索了一级目录与二级，此处 regex 做的事情等价于 <code class="highlighter-rouge">find . -mindepth 2 -maxdepth 2</code>；并且如果有文件名中包含了 <code class="highlighter-rouge">/</code> 字符也会导致 regex 出事。</p>

<p>由于 ERE 正则之渣，强烈不建议在过于复杂的需求中使用 <code class="highlighter-rouge">-regex</code> 吃屎，实在不想写 Python，请老老实实 <code class="highlighter-rouge">find | grep -P</code> 用 pcre 拯救生命，比如上面的排除 .git 目录就可以写成如下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s1">'^(?!.*\.git).*'</span>
</code></pre></div></div>

<p>（你可能需要拜读一番旷世杰作《Mastering Regular Expressions》才能理解上面的正则）</p>

<h4 id="12-for">1.2 <code class="highlighter-rouge">for</code></h4>

<p><code class="highlighter-rouge">find</code> 的强大是毋庸置疑的，但是也不要忽略了 <code class="highlighter-rouge">for</code> 的存在啊，尤其是当我们很清楚我们就是只需要迭代到二级子目录去做一些事情的时候，<code class="highlighter-rouge">for</code> 能规避很多 <code class="highlighter-rouge">find</code> 很蛋疼的痛点，稍后会解释，现在先看如何去遍历文件。</p>

<p>首先是正常遍历：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>filename <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>这里很有趣的地方就是 <code class="highlighter-rouge">*</code> 展开时会转义空格等字符，然后 <code class="highlighter-rouge">"filename"</code> 部分引用（我倾向于称之为 <code class="highlighter-rouge">partial quote</code> 而不是 <code class="highlighter-rouge">double quote</code> 是因为这更加 explict）会保证变量不会被 <code class="highlighter-rouge">$IFS</code> 打断为多个参数传递给函数。</p>

<p>如果有一些过滤条件呢也当然没有问题啦：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 默认就是排除 ./.git 的，因为 * 展开不包括隐藏文件</span>

<span class="c"># 包含 .git 进行遍历</span>
<span class="k">for </span>filename <span class="k">in</span> <span class="k">*</span> .git<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># 只遍历目录，相当于 find -type d</span>
<span class="k">for </span>filename <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># 只遍历文件名前缀为 test_ 或者 tests_ 的 py 文件</span>
<span class="k">for </span>filename <span class="k">in</span> <span class="k">*</span>.py<span class="p">;</span> <span class="k">do</span> <span class="o">[[</span> <span class="o">!</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="o">=</span>~ test_.<span class="k">*</span>|tests_.<span class="k">*</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># 遍历二级目录</span>
<span class="k">for </span>dirname <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do for </span>filename <span class="k">in</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span>/<span class="k">*</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>几个需要强调的细节如下：</p>

<ol>
  <li>测试表达式 <code class="highlighter-rouge">[ ... ]</code> 是很容易出错的，请仅仅在使用 operator 的时候使用它，如上面的 <code class="highlighter-rouge">-d</code> 检查是否目录，并且保证所有的变量都被部分引用，以及空格都健在，尤其是方括号与其他字符直接的空格。</li>
  <li>请使用更加弹性的 <code class="highlighter-rouge">[[ ... ]]</code> 测试表达式，其中常用的操作不仅包括 <code class="highlighter-rouge">==</code> 检查相等，更加包括 <code class="highlighter-rouge">=~</code> 正则表达式匹配。请注意使用 <code class="highlighter-rouge">=~</code> 时请不要引用右侧的正则表达式。</li>
  <li>部分引用会抑制 <code class="highlighter-rouge">*</code> 展开，所以如果需要拼接二级目录并展开迭代，像上面一样 <code class="highlighter-rouge">for filename in "$dirname"/*</code> 而不要 <code class="highlighter-rouge">"$dirname/*"</code>。</li>
</ol>

<p>多重条件请务必在条件表达式之外使用短路与 <code class="highlighter-rouge">&amp;&amp;</code> 短路或 <code class="highlighter-rouge">||</code>，类似 <code class="highlighter-rouge">[ expr1 &amp;&amp; expr2 ]</code> 会死得很难看。虽然你可以使用 <code class="highlighter-rouge">-a</code> / <code class="highlighter-rouge">-o</code> operator，但我还是建议统一使用 <code class="highlighter-rouge">&amp;&amp;</code> / <code class="highlighter-rouge">||</code>，无论是 <code class="highlighter-rouge">[ ... ]</code> 还是 <code class="highlighter-rouge">[[ ... ]]</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 多重条件之 ||</span>
<span class="k">for </span>dirname <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"tests"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>

<span class="c"># 多重条件之 -o</span>
<span class="k">for </span>dirname <span class="k">in</span> <span class="k">*</span><span class="p">;</span> <span class="k">do</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span> <span class="nt">-o</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"tests"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$dirname</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>如果没有找到匹配模式的文件，a.k.a <code class="highlighter-rouge">*</code> 展开失败，那么会 for 循环依然会进行一次，但是变量被赋值为未展开的值，所以建议对展开失败的情况进行判断：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>filename <span class="k">in </span>not_exist_file<span class="k">*</span><span class="p">;</span> <span class="k">do</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<hr />
<h3 id="2-file-name-handling">2. File Name Handling</h3>

<p>我们可以遍历文件了，但是如何依次引用每个文件的文件名呢？</p>

<h4 id="21-find">2.1 <code class="highlighter-rouge">find</code></h4>

<p>直接使用 <code class="highlighter-rouge">find</code> 的 <code class="highlighter-rouge">-exec</code> 是没问题的，但是会有几个注意事项，先看简单的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 删除所有的 py 文件</span>
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-exec</span> rm <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<p>简单来说呢就是 <code class="highlighter-rouge">{}</code> 会被替换为 <code class="highlighter-rouge">find</code> 输出的每个文件名，然后你就可以为所欲为了。最后的 <code class="highlighter-rouge">\;</code> 只是为了不让 Shell 把 <code class="highlighter-rouge">;</code> 解释了，这个 <code class="highlighter-rouge">;</code> 可是要留给 <code class="highlighter-rouge">find</code> 命令去 interprete 的。</p>

<p>不过删除这种事已经可以被 <code class="highlighter-rouge">find -delete</code> 做了，所以如果我们要做更复杂的事情怎么办？比如我们要用 Parameter Substitution 把文件名改一下再输出，<code class="highlighter-rouge">{}</code> 这个破玩意儿肯定是不能 Parameter Substitution 的，但是我们可以利用 <code class="highlighter-rouge">bash -c</code> 来处理：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 把所有的 py 文件后缀改为 python 再输出</span>
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-exec</span> /bin/bash <span class="nt">-c</span> <span class="s1">'echo "${0/%.py/.python}"'</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<p>不熟悉 Shell Parameter Substitution 的朋友建议<del>自杀</del>通读一遍文档，下同。</p>

<p>可以看到用这种套路我们的 <code class="highlighter-rouge">-exec</code> 一下子就变得非常灵活了，我们甚至可以写多条语句和循环在 <code class="highlighter-rouge">bash -c</code> 中，但是需要注意的是 <code class="highlighter-rouge">-exec</code> 调用了子进程，一切调用子进程的都有两个问题：</p>

<ol>
  <li>环境变量容易坑爹。比如 crond job 动不动就不能执行，多半就是因为环境变量问题，建议 <code class="highlighter-rouge">echo $PATH</code> 并且调用绝对路径。</li>
  <li>子进程中的变量无法（简单）被父进程使用。比如你在子进程中做了什么奇怪的统计然后想累加到父进程的什么变量上，然后运行完了发现父进程的变量还是一字不变，就是踩了子进程的坑。</li>
</ol>

<p>不过在执行简单任务上这已经完全足够我们折腾了，比如我有个脚本用来转换 flac 到 mp3，就是简单调用 <code class="highlighter-rouge">bash -c</code> 加上 Parameter Substitution：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.flac'</span> <span class="nt">-exec</span> /bin/bash <span class="nt">-c</span> <span class="s1">'ffmpeg -y -i "$0" "${0%.flac}.mp3"'</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<h4 id="22-xargs">2.2 <code class="highlighter-rouge">xargs</code></h4>

<p>xargs 一直被广大人民群众所喜爱，然后年轻人又经常处理不好奇怪的文件名。</p>

<p>正确使用 xargs 的姿势是 <code class="highlighter-rouge">find -print0 | xargs -0</code> 使用 <code class="highlighter-rouge">\0</code> 字符分隔文件名，避免文件名中包含 <code class="highlighter-rouge">$IFS</code> 的文件搞死你：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span> | xargs <span class="nt">-0</span> rm <span class="nt">-f</span>
</code></pre></div></div>

<p>对于稍复杂的情况，和上面 <code class="highlighter-rouge">-exec</code> 一样，祭出 <code class="highlighter-rouge">bash -c</code> 大法：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span> | xargs <span class="nt">-I</span><span class="o">{}</span> <span class="nt">-0</span> /bin/bash <span class="nt">-c</span> <span class="s1">'echo "${0/%.py/.python}"'</span> <span class="o">{}</span>
</code></pre></div></div>

<p>那么这样的话上面那个转换 flac 的脚本就变成了这样：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.flac'</span> <span class="nt">-print0</span> | xargs <span class="nt">-I</span><span class="o">{}</span> <span class="nt">-0</span> /bin/bash <span class="nt">-c</span> <span class="s1">'ffmpeg -y -i "$0" "${0%.flac}.mp3"'</span> <span class="o">{}</span>
</code></pre></div></div>

<p>xargs 最爽的地方就是可以很容易并行，只需要简单加个 <code class="highlighter-rouge">-P</code> 选项，轻轻松松性能翻番：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.flac'</span> <span class="nt">-print0</span> | xargs <span class="nt">-P0</span> <span class="nt">-I</span><span class="o">{}</span> <span class="nt">-0</span> /bin/bash <span class="nt">-c</span> <span class="s1">'ffmpeg -y -i "$0" "${0%.flac}.mp3"'</span> <span class="o">{}</span>
</code></pre></div></div>

<p>我使用 <code class="highlighter-rouge">-P0</code> 指定使用尽可能多的进程去运行，使用 <code class="highlighter-rouge">TIME(1)</code> 去测试性能，转换一张滚石专辑耗时从 <code class="highlighter-rouge">5m46.635s</code> 跃迁到 <code class="highlighter-rouge">2m36.474s</code>。</p>

<p>然而 <code class="highlighter-rouge">xargs</code> 最大的问题是命令存在一个字符数上限，而 <code class="highlighter-rouge">find -exec</code> 也一样，所以如果特别复杂的命令会有问题，然而一般来说我们不太可能会运行一个 1Kib 的 xargs，而是会写一个 sh 脚本来运行。</p>

<p>我个人的口味来说不喜欢用绝对引用把代码包起来，这会让我的单双引号变得无所适从，所以我愿意用 Here 文档与 Command Substitution 来做这件事：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.flac'</span> <span class="nt">-print0</span> | xargs <span class="nt">-P0</span> <span class="nt">-I</span><span class="o">{}</span> <span class="nt">-0</span> /bin/bash <span class="nt">-c</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
ffmpeg -y -i "</span><span class="nv">$0</span><span class="sh">" "</span><span class="k">${</span><span class="nv">0</span><span class="p">%.flac</span><span class="k">}</span><span class="sh">.mp3"
</span><span class="no">EOF
</span><span class="k">)</span><span class="s2">"</span> <span class="o">{}</span>
</code></pre></div></div>

<p>这样循环啊多重语句啊什么的都可以通过 Here 文档分行，可读性能提高不少，代价是逼格下降不少。</p>

<p>另一个问题是管道总是创建子进程来运行命令，导致的问题是说，如果你希望最终的结果是改变父进程的某个值就会变得非常坑爹了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">py_cnt</span><span class="o">=</span>0
find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span> | xargs <span class="nt">-0</span> /bin/bash <span class="nt">-c</span> <span class="s1">'((py_cnt++))'</span>
<span class="nb">echo</span> <span class="nv">$py_cnt</span>
</code></pre></div></div>

<p>上面的代码无论如何输出都是 0，就是因为如此。</p>

<p>我们继续前进。</p>

<h4 id="23-read">2.3 <code class="highlighter-rouge">read</code></h4>

<p>read 一开始我是觉得挺难掌握的，主要是内心有点抗拒，觉得 useless，但是上手后迅速就熟练了，发现真的很好用！</p>

<p>比如说处理 <code class="highlighter-rouge">\0</code> 分隔的输入：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span> | <span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>还是打印 py 文件那一套，主要细节是 <code class="highlighter-rouge">IFS=</code> 保证了 prefix 的 <code class="highlighter-rouge">$IFS</code> 不会被 strip，而 <code class="highlighter-rouge">read -d ''</code> 指明了读取标准输入直到 <code class="highlighter-rouge">\0</code>，然后在 <code class="highlighter-rouge">while</code> 循环体内处理 <code class="highlighter-rouge">$filename</code> 变量就好了。</p>

<p>那么如何才能规避 subshell 的进程隔离问题呢？两个方案：Command Substitution 和 Process Substitution。</p>

<p>使用 Command Substitution 的话需要注意的地方是 <code class="highlighter-rouge">\0</code> 经过部分引用后就被吃掉了，也就说如下的 shell 脚本是不 work 的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># WARNING: not working</span>
<span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="k">$(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span><span class="k">)</span><span class="s2">"</span>
</code></pre></div></div>

<p>所以如果想使用 Command Substitution + Here String 的方法就不能用 <code class="highlighter-rouge">\0</code> 做分隔。但是如果我们可以肯定都是正常的文件的话，那么用 <code class="highlighter-rouge">\n</code> 作为分隔也是不错的选择，因此我们不妨这样：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">$'</span><span class="se">\n</span><span class="s1">'</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="k">$(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span><span class="k">)</span><span class="s2">"</span>
</code></pre></div></div>

<p>仅仅是简单把 <code class="highlighter-rouge">-d</code> 的参数从 <code class="highlighter-rouge">''</code> 改为 <code class="highlighter-rouge">$'\n'</code>，b.t.w. <code class="highlighter-rouge">''</code> 也只是 <code class="highlighter-rouge">$'\0'</code> 的简写；然后让 <code class="highlighter-rouge">find</code> 命令自然输出，which 分隔符就是 <code class="highlighter-rouge">\n</code>。</p>

<p>另外一种做法是 Process Substitution：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span> &lt; &lt;<span class="o">(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">&lt;(cmd)</code> Process Substitution 是非常有用的，它与 <code class="highlighter-rouge">"$(cmd)"</code> Command Substitution 的区别是很微妙的，前者是把整个命令的输出作为一个输入，后者是把整个命令的输出打印出来，听上去有点 <code class="highlighter-rouge">$*</code> 之于 <code class="highlighter-rouge">#$@</code> 的感觉。要注意其中的空格不能多也不能少！</p>

<p>在某些情况下接受标准输入是会出现问题的，因为 while 循环主体与 read 可以读取同一个文件描述符 0，所以一旦 while 循环主体也要读取 stdin 那就坏事了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> line &lt;&amp;0<span class="p">;</span> <span class="nb">echo</span> <span class="s2">"-&gt;</span><span class="nv">$line</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span> &lt; &lt;<span class="o">(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span><span class="o">)</span>
</code></pre></div></div>

<p>如果亲自运行一下再与之前的对比一下就会发现输出的东西少了整整一半，这是隐患，真正出问题的代码不会这么明显地写着从 0 读取。曾经遇到的问题是 <code class="highlighter-rouge">ffmpeg</code> 居然会调用一个子命令，它们之间居然用 stdin / stdout 来通信，如果你已经用管道占用了 stdin 的话连报错都看不懂。</p>

<p>正确的做法应该从另外的文件描述符进行输入，由于使用了 Process Substitution 这是很容易办到的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-u3</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> filename<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span><span class="p">;</span> <span class="k">done </span>3&lt; &lt;<span class="o">(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span><span class="o">)</span>
</code></pre></div></div>

<p>唯一的修改就是让 <code class="highlighter-rouge">read -u3</code> 从 3 读取，然后让 <code class="highlighter-rouge">find</code> 的输出导入 3。</p>

<p>如此这般，我们现在应该完全可以进行任何的命令了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">py_cnt</span><span class="o">=</span>0
<span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-u3</span> <span class="nt">-r</span> <span class="nt">-d</span> <span class="s1">''</span> _<span class="p">;</span> <span class="k">do</span> <span class="o">((</span>py_cnt++<span class="o">))</span><span class="p">;</span> <span class="k">done </span>3&lt; &lt;<span class="o">(</span>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.py'</span> <span class="nt">-print0</span><span class="o">)</span>
<span class="nb">echo</span> <span class="nv">$py_cnt</span>
</code></pre></div></div>

<p>再弱弱提一句，read 的 fields split 能力也是超级好用的，比如说要取出 <code class="highlighter-rouge">ls -l</code> 输出中的 group 与 user，那么可以：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-l</span> | <span class="o">(</span><span class="k">while </span><span class="nb">read </span>_ _ user group _<span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$user</span><span class="s2"> -&gt; </span><span class="nv">$group</span><span class="s2">"</span><span class="p">;</span> <span class="k">done</span><span class="o">)</span>
</code></pre></div></div>

<p>如果有需要也可是直接修改 <code class="highlighter-rouge">IFS</code>，轻松切列。</p>

<h4 id="24-for">2.4 <code class="highlighter-rouge">for</code></h4>

<p>我们应该已经有了一个完全可靠的变量文件的脚本了，但是我还是想回过头看一下 for 循环。</p>

<p>使用 for 循环天然就规避了很多问题：</p>

<ol>
  <li>没有使用管道，因此没有 subshell，也不会占用标准输入。</li>
  <li><code class="highlighter-rouge">*</code> 展开自动转义，不需要人工处理 <code class="highlighter-rouge">\0</code> 之类的东西，省心。</li>
</ol>

<p>因此如果我们确认一定以及肯定我们遍历的目录深度就是 2，那么请大胆使用 for。我曾经给我的专辑批量加上 mid3v2 标签的时候写过这样的脚本：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span>dir <span class="k">in</span> <span class="o">[</span>1-9]<span class="k">*</span><span class="p">;</span> <span class="k">do 
    </span><span class="nv">folder</span><span class="o">=</span><span class="s2">"</span><span class="nv">$dir</span><span class="s2">/Folder.jpg"</span><span class="p">;</span> 
    <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$folder</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="k">continue</span><span class="p">;</span> 
    <span class="k">for </span>mp3 <span class="k">in</span> <span class="s2">"</span><span class="nv">$dir</span><span class="s2">"</span>/<span class="k">*</span>.mp3<span class="p">;</span> <span class="k">do 
        </span>mid3v2 <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$folder</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$mp3</span><span class="s2">"</span><span class="p">;</span> 
    <span class="k">done</span><span class="p">;</span> 
<span class="k">done</span>
</code></pre></div></div>

<p>同时我想敬告试图使用 for 去迭代 find 输出的朋友，通过修改 IFS 是可以做到的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
IFS=</span><span class="nv">$'</span><span class="sh">\n'
for filename in </span><span class="k">$(</span>find <span class="nt">-name</span> <span class="s1">'*.py'</span><span class="k">)</span><span class="sh">; do echo "-&gt;</span><span class="nv">$filename</span><span class="sh">"; done
</span><span class="no">EOF
</span></code></pre></div></div>

<p>但是非常容易出错！第一是建议在 subshell 中运行，避免修改了 IFS 还要切换回来；第二是只能让 IFS 值为 <code class="highlighter-rouge">\n</code> 而不能为 <code class="highlighter-rouge">\0</code>，否则在展开 Command Substitution 的时候 <code class="highlighter-rouge">\0</code> 会被吃掉，然后会变成一坨打印出来；第三是 Command Substitution 一定不能被引用，部分引用也不行 (<code class="highlighter-rouge">"$(find)"</code>)，否则 Shell 会把整个输出作为一个不可分割的整体塞给 for 去迭代。</p>

<hr />
<h3 id="3-批处理文本">3. 批处理文本</h3>

<p>下面来谈谈批处理文本文件的问题，这个需求在实际工作中偶尔会遇到，遇到的时候还挺恶心的。</p>

<h4 id="31-vim">3.1 <code class="highlighter-rouge">vim</code></h4>

<p>应该毫不质疑 vim 在这种场景下能够发挥出来的作用。大家对 vim 的认识不应该只停留在一个高效的交互式的文本编辑器上，有时候它也可以不交互。不要忘了它的祖先可是 ex 和 ed。</p>

<p>最常见的问题是批量替换，比方说，我们要批量替换一大大大堆文件里的端口号，40000 -&gt; 40001，比方说，比方说啊。</p>

<p>那么使用 vim 来做的话会很容易：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim +<span class="s1">'%s/\v&lt;40000&gt;/40001/g'</span> +x &lt;file&gt;
</code></pre></div></div>

<p>给部分 IDE 玩家简单解释一下其中可能陌生的元素：<code class="highlighter-rouge">\v</code> 表示使用 <code class="highlighter-rouge">very magic</code> 模式，<code class="highlighter-rouge">&lt;</code> 与 <code class="highlighter-rouge">&gt;</code> 在 <code class="highlighter-rouge">very magic</code> 模式下匹配单词的开始与结束（类似 pcre 里的 <code class="highlighter-rouge">\b</code>），然后用 <code class="highlighter-rouge">vim +{command}</code> 来执行 ex 命令。</p>

<p>如果我有多个端口要替换呢，比方说 40000 -&gt; 40001, 30000 -&gt; 30001, 20000 -&gt; 20001：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">' &gt;subport.ex
%s/\v&lt;40000&gt;/40001/g
%s/\v&lt;30000&gt;/30001/g
%s/\v&lt;20000&gt;/20001/g
x
</span><span class="no">EOF
</span>vim <span class="nt">-S</span> subport.ex &lt;file&gt;
</code></pre></div></div>

<p>很好理解，就是把 ex 命令都写到一个文件里，然后用 <code class="highlighter-rouge">vim -S</code> 来执行。</p>

<p>所以要批处理的话就超级简单啦，之前已经做了足够的讨论，因为没有副作用，直接用 <code class="highlighter-rouge">find -exec</code>：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-type</span> f <span class="nt">-exec</span> vim <span class="nt">-S</span> subport.ex <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div>

<p>但是这样会把每个文件都替换一遍，就算什么都没有也替换一遍，太暴力了，不妨 grep 一下先：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-r</span> <span class="nb">.</span> <span class="nt">-P</span> <span class="s1">'\b[234]0000\b'</span> <span class="nt">-lZ</span> | xargs <span class="nt">-0</span> <span class="nt">-I</span><span class="o">{}</span> vim <span class="nt">-S</span> subport.ex <span class="o">{}</span>
</code></pre></div></div>

<p>grep 的 <code class="highlighter-rouge">-P</code> 使用 pcre，<code class="highlighter-rouge">-l</code> 只输出匹配到的文件名，<code class="highlighter-rouge">-Z</code> 以 <code class="highlighter-rouge">\0</code> 作为文件分隔符。奥对了，只有 gnu/grep 才有 <code class="highlighter-rouge">-P</code>，macOS 用户请 <code class="highlighter-rouge">brew install grep --with-default-names</code> 吧~</p>

<p>然而仅仅是替换并不能真正体现出 vim ex 的能力啊，必须要提醒一下 <code class="highlighter-rouge">grep</code> 名称的来源 <code class="highlighter-rouge">g/re/p</code> 就是 vim 前身 ex 的命令，global 命令才是 ex 的精华。</p>

<p>我们来看这么一个 real world 的需求（感谢 BuBu），现在有一堆文件，要把如下的 <code class="highlighter-rouge">to_delete</code> logger 删除：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LOGGING</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'version'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s">'disable_existing_loggers'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
    <span class="s">'loggers'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'to_delete'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'stdout'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'DEBUG'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s">'crumb'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'handlers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'stdout'</span><span class="p">],</span>
            <span class="s">'level'</span><span class="p">:</span> <span class="s">'DEBUG'</span><span class="p">,</span>
            <span class="s">'propagate'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用 global 来做的话是很容易的，只要理解了 <code class="highlighter-rouge">g/re/p</code> 的模式及其变体 <code class="highlighter-rouge">g/re/[range]p</code> 就很容易解决：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep </span>to_delete <span class="nt">-r</span> <span class="nb">.</span> <span class="nt">-lZ</span> | xargs <span class="nt">-0</span> <span class="nt">-I</span><span class="o">{}</span> vim +<span class="s1">'g/\v&lt;LOGGING&gt;/ /to_delete/,/}/d'</span> +xa <span class="o">{}</span>
</code></pre></div></div>

<p>重点是管道之后用 vim 运行的 ex 命令，用 <code class="highlighter-rouge">g/re/[range]p</code> 的模式来拆分的话，<code class="highlighter-rouge">/re/</code> 是 <code class="highlighter-rouge">/\v&lt;LOGGING&gt;/</code>，搜索出 LOGGING 单词；<code class="highlighter-rouge">[range]</code> 是 <code class="highlighter-rouge">/to_delete/,/}/</code>，从 <code class="highlighter-rouge">to_delete</code> 到 <code class="highlighter-rouge">}</code> 直接的行；<code class="highlighter-rouge">p</code> 是 <code class="highlighter-rouge">d</code>，即 ex 命令中的删除。
所以整个 ex 命令的意思是：找到每个 <code class="highlighter-rouge">LOGGING</code> 单词，然后从它之后的代码中把 <code class="highlighter-rouge">to_delete</code> 至 <code class="highlighter-rouge">}</code> 直接的行都删除。</p>

<p>或者直接使用 range 命令来操作也是可行的（我就直接撸 ex 好啦，自行脑补上 <code class="highlighter-rouge">grep</code>）：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim +<span class="s1">'/to_delete/;/}/d'</span> +xa &lt;file&gt;
</code></pre></div></div>

<p>也很好理解啦，就是搜索出 <code class="highlighter-rouge">to_delete</code> 到 <code class="highlighter-rouge">}</code> 之间的行再直接 <code class="highlighter-rouge">d</code>。请注意细节是 <code class="highlighter-rouge">;</code> 表明 range 的右边界是从左边界开始搜索的，如果使用 <code class="highlighter-rouge">,</code> 的话右边界就是与左边界搜索起点相同进行搜索，多半会造成错误的删除。</p>

<p>就是这样。</p>

<h4 id="32-sed">3.2 <code class="highlighter-rouge">sed</code></h4>

<p>sed 一度让我沉迷，以致于我居然写出来过 <code class="highlighter-rouge">sed -En ':next; N; $p; '$k',$D; $!b next'</code> 和 <code class="highlighter-rouge">sed -En '/\{/,/}/{/\{/h; /\{/!H; x; s/(.+)\n(.+)/\2\n\1/; h; /}/p;};'</code> 这样的代码，真是太可怕了，我现在完全看不懂。</p>

<p>这篇文章的目的将始终致力于让人们在生活中利用 shell 工具提高生产力，沉迷炫技是不对的，虽然我经常这么干。</p>

<p>sed 最常用的用途就是批量替换啦，虽然在已经有 vim 的解决方案下我完全不知道使用 sed 还有什么意义，但是要知道 vim 并不是哪里都有的，比如 Docker 容器内，所以我们还是要掌握一定的 sed 技能。虽然连 vim 都没有的环境多半也没有 sed。</p>

<p>那么还是老问题，把 40000 端口替换为 40001：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed <span class="nt">-i</span>.bak <span class="s1">'s/40000/40001/g'</span> &lt;file&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">-i.bak</code> 表明把被替换的文件做一个备份而不是原地替换，在没有版本控制的环境下这是能救命的。</p>

<p>有意思的地方是 sed 天然能够接受多文件作为输入参数，所以我们（在能够确保没有异形文件名的情况下）可以大胆一点：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed <span class="nt">-i</span>.bak <span class="s1">'s/40000/40001/g'</span> <span class="k">$(</span><span class="nb">grep</span> <span class="nt">-P</span> <span class="s1">'\b40000\b'</span> <span class="nt">-r</span> <span class="nb">.</span> <span class="nt">-l</span><span class="k">)</span>
</code></pre></div></div>

<p>这样做的好处是减少了 sed 调用次数与 fork 出来的进程数，同时利用 <code class="highlighter-rouge">grep -P</code> 我们可以大胆用 pcre 筛选出要替换的文件，而不用拘泥于蹩脚的 ERE，是的，<code class="highlighter-rouge">sed -E</code> 也是渣。</p>

<p>至于其他的魔幻使用方式，比如 hold 空间什么的，我就这么说吧，正常人根本不会有什么需求会要你用 sed 输出文本文件的倒数 k 行之类的操作（好的我知道 <code class="highlighter-rouge">tail -k</code>），如果真的发现开始变得恶心起来，请果断用 Python 大法。所以对 sed 的掌握请浅尝辄止。</p>

<h4 id="33-awk">3.3 <code class="highlighter-rouge">awk</code></h4>

<p>awk 是一门编程语言，毫无疑问。只不过是古代语言。</p>

<p>然而只有神经病才会天天没事用 <code class="highlighter-rouge">getline</code> 读取管道再调用 <code class="highlighter-rouge">substr</code> 之类的函数来做一些奇怪的事情。</p>

<p>让我们着眼于它的优势之处：filter 与 fields split。</p>

<p>比如说众所周知 <code class="highlighter-rouge">docker images --filter</code> 基本就是废的，那我们想删除名字中包含 <code class="highlighter-rouge">einplus</code> 的镜像应该怎么做？<del>（请 <code class="highlighter-rouge">grep | cut</code> 党去死，谢谢）</del></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi <span class="nt">-f</span> <span class="k">$(</span>docker images | awk <span class="s1">'$1 ~ /einplus/ { print $3 }'</span><span class="k">)</span>
</code></pre></div></div>

<p>用 awk 的话就会非常流畅，<code class="highlighter-rouge">$1</code> 与 <code class="highlighter-rouge">$3</code> 非常精确地取出镜像名字与 ID，然后匹配名字、输出 ID。</p>

<p>当然提到切列的时候永远不要忘了 read：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker rmi <span class="nt">-f</span> <span class="k">$(</span>docker images | <span class="k">while </span><span class="nb">read </span>name _ id _<span class="p">;</span> <span class="k">do</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$name</span><span class="s2">"</span> <span class="o">=</span>~ .<span class="k">*</span>einplus.<span class="k">*</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$id</span><span class="s2">"</span><span class="p">;</span> <span class="k">done)</span>
</code></pre></div></div>

<p>也是非常痛快的！</p>

<p>再比如我就曾经写过一个命令，批处理我的 mp3 文件，让它们的 TIT2 信息作为文件名，代码是这样的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find <span class="nb">.</span> <span class="nt">-name</span> <span class="s1">'*.mp3'</span> <span class="nt">-print0</span> | <span class="k">while </span><span class="nb">read</span> <span class="nt">-d</span> <span class="s1">''</span> <span class="nt">-r</span> filename<span class="p">;</span> <span class="k">do </span>mid3v2 <span class="nt">-l</span> <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> | mv <span class="s2">"</span><span class="nv">$filename</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">filename</span><span class="p">%/*</span><span class="k">}</span><span class="s2">/</span><span class="k">$(</span>awk <span class="nt">-F</span><span class="o">=</span> <span class="s1">'$1 ~ /TIT2/ { print $2 }'</span><span class="k">)</span><span class="s2">.mp3"</span><span class="p">;</span> <span class="k">done</span>
</code></pre></div></div>

<p>可以说是很酣畅淋漓了。</p>

<p>另外不得不提的是，awk 对文本块的处理几乎是一切 shell tools 里最轻巧的，相比 perl 记不完的变量、python 上来就写脚本（线上容器 vi 写脚本了解一下），awk 在某些不那么复杂的需求下简直犀利。</p>

<p>比如我的需求是提取出一个 yaml 文件中所有类型是 <code class="highlighter-rouge">cronjob</code> 的并且每天运行的任务的 <code class="highlighter-rouge">cmd</code>，yaml 文件长这样：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">job1</span><span class="pi">:</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">cronjob</span>
    <span class="na">cmd</span><span class="pi">:</span> <span class="s">job1</span>
    <span class="na">schedule</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0</span><span class="nv"> </span><span class="s">18</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*"</span>

<span class="na">job2</span><span class="pi">:</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">cronjob</span>
    <span class="na">cmd</span><span class="pi">:</span> <span class="s">job2</span>
    <span class="na">schedule</span><span class="pi">:</span> <span class="s2">"</span><span class="s">50</span><span class="nv"> </span><span class="s">18</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*</span><span class="nv"> </span><span class="s">*"</span>

<span class="na">job3</span><span class="pi">:</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">daemon</span>
    <span class="na">cmd</span><span class="pi">:</span> <span class="s">./manage.py corpus_patch_es</span>
</code></pre></div></div>

<p>那么我的 awk 可以这样写：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awk <span class="nt">-F</span><span class="s1">$'</span><span class="se">\n</span><span class="s1">'</span> <span class="nt">-v</span> <span class="nv">RS</span><span class="o">=</span> <span class="s1">'$0 ~ /cronjob/ &amp;&amp; /\* \* \*/ {print $0}'</span> offline.yaml | <span class="nb">grep</span> <span class="nt">-P</span> <span class="s1">'(?&lt;=cmd: ).+'</span> <span class="nt">-o</span>
</code></pre></div></div>

<p>其中需要特别强调是 <code class="highlighter-rouge">-F$'\n'</code> 让 awk 以换行作为列分隔，这样每个 <code class="highlighter-rouge">$0</code> 就是一整个文本块，然后剩下的就很容易了。</p>

<p>简直爽！</p>

<hr />

<p>说了这么多，其实想熟练使用 Shell 提高生产力，最重要的还是练习啦。相比其他前十语言来说，Shell 的动态弱类型实在是太古灵精怪了，多加一个引号就完全不一样，各种潜规则也层出不穷，多踩chi坑shi，相信明天会更好 \^o^/</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">小生境</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jschwinger23
            
            </li>
            
            <li><a href="mailto:greyschwinger@gmail.com">greyschwinger@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jschwinger23"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jschwinger23</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Live to tell
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
