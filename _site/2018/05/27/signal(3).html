<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/rss+xml" title="小生境" href="/feed.xml">
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">小生境</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline"> signal(3)</h1>
    <p class="post-meta">
      <time datetime="2018-05-27T00:00:00+08:00" itemprop="datePublished">
        
        2018-05-27
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>这是工作以来对 Linux 信号的肤浅讨论和思考。</p>

<hr />
<h3 id="一异步信号安全">一、异步信号安全</h3>

<p>似乎做 Web 开发的同学里知道这个并不多？</p>

<p>TL;DR</p>

<p>信号作为 Linux 异步通知机制之一，其 <strong>异步</strong> 的特性大家一定有了解。简单说就是两点：</p>

<ol>
  <li>你指定进程发出信号之后，那个进程究竟在什么时候会收到信号，其实是一个迷。（好的我知道自己给自己可以发同步信号）</li>
  <li>进程收到信号之后，理论上可能中断任何正在执行的非原子指令、转而运行信号处理器，那么 race condition 风险已经不言而喻了。</li>
</ol>

<p>如果一个函数在信号处理器中被调用不会导致 race condition，那么称该函数是 <strong>异步信号安全(async-signal-safe)</strong> 的。</p>

<p>具体来讲，我们可能有几种情况会导致信号处理器出现 race condition：</p>

<p><strong>1. 信号处理器调用不可重入函数。</strong></p>

<p>在 SUSv3 中对可重入 (reentrant) 的概念定义是很清晰的：</p>

<blockquote>
  <p>whose effect, when called by two or more threads, is guaranteed to be as if the threads each executed the function one after the other in an undefined order, even if the actual execution is interleaved.</p>
</blockquote>

<p>比方说一个函数更新全局变量，那它就是不可重入。<code class="highlighter-rouge">malloc</code> 和 <code class="highlighter-rouge">free</code> 维护堆区已释放内存块的链表，如果在执行 <code class="highlighter-rouge">malloc</code> 的时候被同样调用 <code class="highlighter-rouge">malloc</code> 的信号处理器中断，那么链表就可能被破坏了。</p>

<p><strong>2. 信号处理器自己去更新全局变量。</strong></p>

<p>这是老生常谈的事情了，多线程玩家早就非常熟悉一套。该加锁的加锁，该加条件变量的加条件变量，不多讲。</p>

<p>我们举个具体的例子，<code class="highlighter-rouge">crypt</code>。</p>

<p><code class="highlighter-rouge">crypt</code> 不是可重入的，因为它使用了静态分配的内存来返回数据，如果信号处理器调用了它，那么会覆盖主程序中上一次调用同一函数所返回的数据。</p>

<p>用 Python + ctypes 来做这件事的话会非常清楚：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// handle_sigint.c
</span>
<span class="cp">#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">crypt</span><span class="p">(</span><span class="s">"__"</span><span class="p">,</span> <span class="s">"xx"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">handle_sigint</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>用 C 注册 SIGINT 的处理器，等下解释为什么一定要用 C。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc handle_sigint.c <span class="nt">-shared</span> <span class="nt">-o</span> handle_sigint.so
</code></pre></div></div>

<p>然后编译为共享库 <code class="highlighter-rouge">handle_sigint.so</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># reentrant_sig_handler.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">crypt</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">salt</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span>

    <span class="n">module</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s">'./handle_sigint.so'</span><span class="p">))</span>
    <span class="n">module</span><span class="o">.</span><span class="n">handle_sigint</span><span class="p">()</span>
    <span class="n">correct_password</span> <span class="o">=</span> <span class="n">crypt</span><span class="o">.</span><span class="n">crypt</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">salt</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">crypt</span><span class="o">.</span><span class="n">crypt</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">salt</span><span class="p">)</span> <span class="o">==</span> <span class="n">correct_password</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>最后利用 <code class="highlighter-rouge">ctypes</code> 大法在 Python 中注册刚才的 SIGINT 处理器，然后运行，按下 <code class="highlighter-rouge">^C</code>：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python reentrant_sig_handler.py asdf as
^CTraceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"reentrant_sig_handler.py"</span>, line 46, <span class="k">in</span> &lt;module&gt;
    main<span class="o">()</span>
  File <span class="s2">"reentrant_sig_handler.py"</span>, line 42, <span class="k">in </span>main
    assert crypt.crypt<span class="o">(</span>word1, salt<span class="o">)</span> <span class="o">==</span> correct_password
AssertionError
</code></pre></div></div>

<p>可以看到我们一旦发送 SIGINT 信号给进程，就会立刻因为信号处理器扰乱了 <code class="highlighter-rouge">crypt</code> 的静态内存导致主程序状态紊乱。</p>

<p>看起来是很可怕的事情，但是我们平时写信号处理器的时候从来没有顾忌任何的函数是否异步信号安全，居然也没出什么事故，这是为什么？</p>

<p>我们再来看一下一个纯 Python 版本的代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">,</span> <span class="n">salt</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span>

    <span class="k">def</span> <span class="nf">int_handler</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">crypt</span><span class="o">.</span><span class="n">crypt</span><span class="p">(</span><span class="n">word2</span><span class="p">,</span> <span class="n">salt</span><span class="p">)</span>

    <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">int_handler</span><span class="p">)</span>
    <span class="n">correct_password</span> <span class="o">=</span> <span class="n">crypt</span><span class="o">.</span><span class="n">crypt</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">salt</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">crypt</span><span class="o">.</span><span class="n">crypt</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">salt</span><span class="p">)</span> <span class="o">==</span> <span class="n">correct_password</span>
</code></pre></div></div>

<p>如上的代码就不会因为信号处理器中断 <code class="highlighter-rouge">crypt</code> 导致异常。</p>

<p>在文档中 (https://docs.python.org/3.4/library/signal.html#execution-of-python-signal-handlers) 有如下说明：</p>

<blockquote>
  <p>A Python signal handler does not get executed inside the low-level (C) signal handler. Instead, the low-level signal handler sets a flag which tells the virtual machine to execute the corresponding Python signal handler at a later point(for example at the next bytecode instruction).</p>
</blockquote>

<p>具体来讲，我们需要知道以下事实：</p>

<ol>
  <li>我们自定义的 sig_handler，最终实际上并没有注册到内核中，而仅仅是<a href="https://github.com/python/cpython/blob/d54cfb160c626626394e2f171d3ccfe03309f34e/Modules/signalmodule.c#L472">保存在一个静态数组中</a>；真正注册到内核中的相应的信号处理器，其实是一个<a href="https://github.com/python/cpython/blob/d54cfb160c626626394e2f171d3ccfe03309f34e/Modules/signalmodule.c#L316">标记函数</a>，标记某个信号来过了。</li>
  <li>解释器主循环中调用 <a href="https://github.com/python/cpython/blob/3a9ccee0e5dbf7d67f5ab79f6095755969db117c/Python/ceval.c#L950">Py_MakePendingCalls</a> 从而调用 <a href="https://github.com/python/cpython/blob/3a9ccee0e5dbf7d67f5ab79f6095755969db117c/Python/ceval.c#L394">PyErr_CheckSignals</a>，才得以顺利调用注册的信号处理器。</li>
</ol>

<p>然而这不意味着 Python 里的信号处理器就不会打断内核调用了。上述事实只是针对 <code class="highlighter-rouge">用户自定义信号处理器</code> 而言，但是对于一些重要信号，比如 <code class="highlighter-rouge">SIGINT</code>，依然直接注册到内核，并且由解释器捕捉 <code class="highlighter-rouge">EINTR</code>、返回 <code class="highlighter-rouge">KeyboardInterrupt</code>。</p>

<p>(建议通篇阅读 PEP0475)</p>

<p>(另外 CPython 源码读起来想死，C 语言才是最地道的依赖注入语言，逃)</p>

<p>所以大体上来说，我们只要别在信号处理器中随意操作全局变量就好了，而不必担心 <code class="highlighter-rouge">这个标准库函数是否调用了非异步信号安全的内核 API</code>。</p>

<h3 id="二process-attaching">二、Process Attaching</h3>

<p>在一家以 ALG 作为核心竞争力的公司进行开发，遇到的最恶心的 BUG 莫过于上线之后算法模型与线下表现不一致。抛开如何在 ALG 开发、工程开发、CI/CD 流程上规避这种不一致先不谈，首先面临的问题是 <code class="highlighter-rouge">如何 DEBUG</code> 与 <code class="highlighter-rouge">如何复现 BUG</code>。每当这时候我都恨不得能够钻进那个正在运行的进程里去看 <code class="highlighter-rouge">这个字典到底有没有被热加载更新</code>、<code class="highlighter-rouge">那个算法模块 API 到底是不是表现正常</code>。</p>

<p>那么我们应该如何钻进一个正在运行的进程呢？</p>

<p>考虑一个简单的利用信号的实现：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sigusr1_handler</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">pdb</span>
    <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>


<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sigusr1_handler</span><span class="p">)</span>
</code></pre></div></div>

<p>这种实现非常无脑，抛开问题不管，先说它带来的好处：</p>

<ol>
  <li>SIGUSR1 不会占用其他系统级信号，安全。（更别说 SIGUSR1 是实时信号，同一信号实例能够被多次保序传递，虽然在这个场景并没有什么用）</li>
  <li>以 <code class="highlighter-rouge">pdb.set_trace</code> attach 进程而不是 <code class="highlighter-rouge">code.interact</code> (https://docs.python.org/3/library/code.html#code.interact) 除了能够让我们立刻探索某些单例之外，还能利用 <code class="highlighter-rouge">break</code> 动态打断点再 <code class="highlighter-rouge">continue</code> 到这个断点上看某些生命期短小的变量。</li>
</ol>

<p>但是它带来的问题也很明显：</p>

<ol>
  <li>如果 attach 的进程是一个 server，而进入信号处理器的时候正好进程在处理一个请求还没发出去，那这个请求将一直不响应，客户端超时，之后结束信号处理器之后再发出去响应可能又会遭遇 Connection Reset；</li>
  <li>此时在内核 backlog 里的已经处于 ESTABLISHED 的套接字，由于进程阻塞在信号处理上，这些套接字一直不读不写，上游的 Nginx 判断响应超时之后断开连接，将请求 upstream 给下游服务，听上去就操蛋；</li>
  <li>如果是 Python Server 的话，那一层 WSGI 容器的主进程在子 worker 没有心跳之后也会强行发 KILL 信号，你 pdb 正在玩耍中突然就 KILLED 肯定也是不开心；</li>
  <li>最最最重要的是，当 server 进程是一个后台进程的时候，你无法 attach 一个后台进程到你当前的 tty 里。用更加专业一点的话说，我们无法 undo <code class="highlighter-rouge">disown</code> 这个命令。好的我知道有一些奇幻的工具 <a href="https://github.com/nelhage/reptyr">reptyr</a> 什么的号称可以 <code class="highlighter-rouge">reparent a running program to a new terminal</code>，但是实际使用的时候会有各种问题。</li>
</ol>

<p>所以我们考虑别的方法，比如用其他的 IPC 工具发送语句，用信号通知后台进程接受并执行语句然后返回，我们再去接收。这样一来等于是我们手动模拟一套 REPL。</p>

<p>虽然进入我脑海的第一个 IPC 是 Unix Socket，但是冷静下来后我觉得 Named Pipe 是不错的选择。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">gunicorn.workers.ggevent</span> <span class="kn">import</span> <span class="n">GeventWorker</span>

<span class="n">REPL_G</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">REPL_L</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">REPLGeventWorker</span><span class="p">(</span><span class="n">GeventWorker</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle_usr1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_usr1</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'handling usr1'</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">pipe</span> <span class="o">=</span> <span class="n">f</span><span class="s">'/tmp/{os.getpid()}.pipe'</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pipe</span><span class="p">)</span> <span class="k">as</span> <span class="n">pipe</span><span class="p">:</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">input_data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'p '</span><span class="p">):</span>
                <span class="n">input_data</span> <span class="o">=</span> <span class="n">f</span><span class="s">'print({input_data[2:]})'</span>

            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'will execute `{input_data}`'</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">exec</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">REPL_G</span><span class="p">,</span> <span class="n">REPL_L</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
</code></pre></div></div>

<p>这里 <code class="highlighter-rouge">GeventWorker</code> 开刀了，直接硬编码从 <code class="highlighter-rouge">/tmp/$pid.pipe</code> 读输入、运行。<code class="highlighter-rouge">s/^p (.+)/print(\1)/</code> 是为了省略烦人的 print，从而采用了与 pdb command 一样的 abbr convention。</p>

<p>客户端就简单往这个 pipe 塞语句就行了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">pid</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">pipe</span><span class="o">=</span>/tmp/<span class="nv">$pid</span>.pipe
mkfifo <span class="nv">$pipe</span>
<span class="k">while </span><span class="nb">read </span>statement<span class="p">;</span> <span class="k">do 
    </span><span class="nb">echo</span> <span class="nv">$statement</span> <span class="o">&gt;</span> <span class="nv">$pipe</span> &amp;
    <span class="nb">kill</span> <span class="nt">-s</span> usr1 <span class="nv">$pid</span>
<span class="k">done</span>
</code></pre></div></div>

<p>然后随便写一个 hello world 的 Flask app，运行起来：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gunicorn <span class="nt">-c</span> gunicorn.conf.py app:app <span class="nt">-k</span> repl_gevent_worker.REPLGeventWorker
</code></pre></div></div>

<p>最后找到想要检查的 worker pid，调用上面的脚本就行了：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./gunicorn_worker_repl.sh <span class="nv">$pid</span>
</code></pre></div></div>

<p>大致思路就是这样没错了。内存泄露什么的细节就先不管了。</p>

<p>然而有个问题是，如果我们执行的语句是一句 CPU 密集语句，可能会导致被信号处理器中断的请求无法及时响应。我们最好禁止还在处理请求时被信号处理器中断。</p>

<p>在同步语义下，我们可以很简单地在请求处理时屏蔽相关信号的传递：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">from</span> <span class="nn">gunicorn.workers.sync</span> <span class="kn">import</span> <span class="n">SyncWorker</span>


<span class="k">class</span> <span class="nc">REPLSyncWorker</span><span class="p">(</span><span class="n">SyncWorker</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="p">[</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR1</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">pthread_sigmask</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIG_UNBLOCK</span><span class="p">,</span> <span class="p">[</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGUSR1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">handle_usr1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">handle_usr1</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'handling usr1'</span><span class="p">)</span>
</code></pre></div></div>

<p>感谢 Python3.3+ 提供了标准库级别的 API 让我能够运行 <code class="highlighter-rouge">sigprocmask(3)</code>，否则我只能用 ctypes 表演杂技了。</p>

<p>可以很简单地进行测试，只要在 Flask App 里处理请求的时候睡十秒，然后在此时发送 SIGUSR1，可以确认确实是在响应返回了之后才运行信号处理器，这样我们不用担心如果信号处理器中运行 CPU 密集运算影响还未响应的请求。</p>

<p>但是也仅仅是对于 <code class="highlighter-rouge">SyncWorker</code> 这种简单线性的 Worker 我们能够这么做。这种做法不仅有问题，而且不可迁移到 coroutine-based worker：</p>

<ol>
  <li>运行信号处理器期间，server socket 依然是监听端口，内核依然在处理三次握手，长时间阻塞会导致 backlog 塞满，同时上游大量 timeout；</li>
  <li>对于 GeventWorker 来说，一个请求处理完毕并不代表此时没有其他请求正在处理。</li>
</ol>

<p>我们将在 <code class="highlighter-rouge">Graceful Termination</code> 这一节再来讨论这个问题。</p>

<p>不过再次强调，在高负载下的服务上</p>

<h3 id="三graceful-termination">三、Graceful Termination</h3>

<p>熟悉 Docker 的朋友都知道，当我们试图停止一个容器的时候，(不是 <code class="highlighter-rouge">docker rm -f</code>，你们这些变态)，Docker Daemon 实际上先发送 SIGTERM 给容器内一号进程，等待一段时间后若还没有退出，再发送 SIGKILL 一击必杀。</p>

<p>所以 SIGTERM 被作为一个能够让我们优雅处理后事再退出进程的信号，它的信号处理器应该精心设计，否则正在处理一个请求就直接退出进程了，<code class="highlighter-rouge">RemoteDisconnected</code> 了解一下。</p>

<p><strong>1. Worker</strong></p>

<p>先考虑一个简单的应用，它做两件事：从队列读取一个 URL，然后去 <code class="highlighter-rouge">curl -XGET</code> 它。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>


<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'received {msg} and handling..'</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s">'url'</span><span class="p">],</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectTimeout</span><span class="p">,</span>
            <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'f-king GFW'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'done'</span><span class="p">)</span>
</code></pre></div></div>

<p>我们也需要一个简单的会被 IO Block 随机一段时间的 Producer，随手写一个：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>


<span class="k">class</span> <span class="nc">MockMQ</span><span class="p">:</span>
    <span class="n">URL_MUST_TIMEOUT</span> <span class="o">=</span> <span class="s">'http://www.google.com:81/'</span>

    <span class="k">def</span> <span class="nf">recv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_block</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">'url'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">URL_MUST_TIMEOUT</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">io_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectTimeout</span><span class="p">,</span>
                      <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">):</span>
            <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">URL_MUST_TIMEOUT</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">second</span><span class="p">)</span>


<span class="n">mq</span> <span class="o">=</span> <span class="n">MockMQ</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">feeder</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">mq</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</code></pre></div></div>

<p>钟爱 <code class="highlighter-rouge">http://www.google.com:81/</code> 是因为防火墙会 DROP TCP 包，所以就算没有 GFW 也一定会 ConnectionTimeout。</p>

<p>显而易见，这时候优雅退出进程应该是，我们先停止 feeder 生产消息、再等待 worker 完成正在处理的消息、最后再结束进程。</p>

<p>一个简单做法是用全局变量 <code class="highlighter-rouge">alive</code> 什么的控制主循环，SIGTERM 信号处理器关掉 <code class="highlighter-rouge">alive</code> 就可以停止。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">Msg</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s">'Msg'</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SyncDaemon</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feeder</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Msg</span><span class="p">],</span>
                 <span class="n">worker</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Msg</span><span class="p">],</span> <span class="bp">None</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">install_signal_handlers</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feeder</span> <span class="o">=</span> <span class="n">feeder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">worker</span> <span class="o">=</span> <span class="n">worker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feeder</span><span class="p">())</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'exiting'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">install_signal_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_term</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'recv SIGTERM'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="bp">False</span>
</code></pre></div></div>

<p>偷懒使用 <code class="highlighter-rouge">SIGINT</code> 代替 <code class="highlighter-rouge">SIGTERM</code>，方便我发信号。</p>

<p>测试一下，非常理想：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python daemon.py feeder.feeder worker.worker sync
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
^Crecv SIGTERM
^Crecv SIGTERM
^Crecv SIGTERM
f-king GFW
exiting
</code></pre></div></div>

<p>可以看到我按下三次 <code class="highlighter-rouge">^C</code> 并没有导致进程立刻停止，而是等待 worker 完毕之后再停止。</p>

<p>如果是多线程的话，会更加有趣一些。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ThreadDaemon</span><span class="p">(</span><span class="n">SyncDaemon</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feeder</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">max_thread_num</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">feeder</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_thread_num</span> <span class="o">=</span> <span class="n">max_thread_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">producer</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">produce</span><span class="p">)</span>
        <span class="n">producer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="n">consumers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_thread_num</span><span class="p">):</span>
            <span class="n">consumer</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">,</span> <span class="n">daemon</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">consumer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">consumers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">consumer</span><span class="p">)</span>

        <span class="n">producer</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'exiting, waiting for all jobs done'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'exit'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">produce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feeder</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'feeding msg {msg}'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'got msg {msg}'</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
</code></pre></div></div>

<p>我们用标准库中的线程安全队列省了不少事情。测试一下：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python daemon.py feeder.feeder worker.worker thread
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
^Crecv SIGTERM
feeding msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
exiting, waiting <span class="k">for </span>all <span class="nb">jobs </span><span class="k">done


</span>f-king GFW
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
got msg <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span>
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
f-king GFW
<span class="nb">exit</span>
</code></pre></div></div>

<p>可以注意到我们按下 <code class="highlighter-rouge">^C</code> 之后，producer 停止了从队列取消息，进程等待队列中的消息被全部消费之后才退出。</p>

<p>最后再实现一下用 Gevent：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GeventDaemon</span><span class="p">(</span><span class="n">SyncDaemon</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feeder</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">feeder</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greenlets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alive</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">alive</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feeder</span><span class="p">()</span>
            <span class="n">greenlet</span> <span class="o">=</span> <span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">greenlet</span><span class="o">.</span><span class="n">link</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_completion</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">greenlets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">greenlet</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">'exiting, waiting for all greenlets done'</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">greenlets</span><span class="p">):</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">'exit'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">on_completion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">greenlet</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">greenlets</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">greenlet</span><span class="p">)</span>
</code></pre></div></div>

<p>由于我懒得翻文档，就简单搞了一个 greenlet pool 保存正在运行的 greenlet。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python daemon.py feeder.feeder worker.worker gevent
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
^Crecv SIGTERM
exiting, waiting <span class="k">for </span>all greenlets <span class="k">done
</span>received <span class="o">{</span><span class="s1">'url'</span>: <span class="s1">'http://www.google.com:81/'</span><span class="o">}</span> and handling..
f-king GFW
f-king GFW
f-king GFW
f-king GFW
^Crecv SIGTERM
f-king GFW
<span class="nb">exit</span>
</code></pre></div></div>
<p><strong>2. WSGI Server</strong></p>

<p>如果把 WSGI Server 理解成为 <code class="highlighter-rouge">从内核 backlog 队列中取 tcp package，解析之后扔给 WSGI 应用</code>，那么我们上面的抽象是完全是 Gunicorn 这类 Web Server 的超集。</p>

<p>比方说我们让 feeder 去从从内核 backlog accept 连接：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">feeder</span><span class="p">(</span><span class="n">server_sock</span><span class="p">):</span>
    <span class="n">conn</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">server_sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">'peer_sock'</span><span class="p">:</span> <span class="n">conn</span><span class="p">,</span> <span class="s">'addr'</span><span class="p">:</span> <span class="n">addr</span><span class="p">}</span>
</code></pre></div></div>

<p>然后让 worker 去调用具体的 WSGI App：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">app</span> <span class="kn">import</span> <span class="n">wsgi</span>


<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">):</span>
        <span class="n">reason</span> <span class="o">=</span> <span class="s">'OK'</span> <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">200</span> <span class="k">else</span> <span class="s">'UNKNOWN'</span>
        <span class="n">peer_sock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s">'HTTP/1.1 {status} {reason}</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">header</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">:</span>
            <span class="n">peer_sock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="s">'{header}: {content}</span><span class="se">\n</span><span class="s">'</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">peer_sock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="s">'</span><span class="se">\n</span><span class="s">'</span><span class="p">)</span>

    <span class="n">peer_sock</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="s">'peer_sock'</span><span class="p">]</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">wsgi</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="n">peer_sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resp</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</code></pre></div></div>

<p>好的，这已经是一个<del>基本可用的 Gunicorn。</del></p>

<p>（我省略了一些细节，比如现在必须在 Daemon 类中去 <code class="highlighter-rouge">bind((HOST, PORT))</code> 再传递给 feeder，都是细节）</p>

<p>但是就 <code class="highlighter-rouge">Graceful Termination</code> 这个问题来看，这里的实现是有问题的。</p>

<p>与上一个小节有所不同，Server 的实现中，就算 <code class="highlighter-rouge">alive</code> 设置为 <code class="highlighter-rouge">False</code>、就算我们不再调用 feeder 去 <code class="highlighter-rouge">accept</code>，内核依然在背地里进行 TCP 三握手建立连接，内核中的 backlog 依然在增长，而之后退出进程只会导致客户端发请求遭遇无情 RESET。</p>

<p>所以正确的做法，应该设置 <code class="highlighter-rouge">alive=False</code> 之后，关闭 server 套接字的读半部，让内核不再接受新连接。</p>

<p>核心的问题是因为我们此时的 feeder 运行与否并不能控制内核中的队列关闭与否。</p>

<p>这部分的实现可以参考 Gunicorn 里的 <a href="https://github.com/benoitc/gunicorn/blob/master/gunicorn/workers/gthread.py#L231"><code class="highlighter-rouge">ThreadWorker</code> 实现</a> 与 <a href="https://github.com/benoitc/gunicorn/blob/master/gunicorn/workers/ggevent.py#L124"><code class="highlighter-rouge">GeventWorker</code> 实现</a>。</p>

<p>考虑到这种情况下，我们恐怕很难像之前的代码一样解耦 feeder 与 worker，feeder 必然会集成进入 Daemon 框架，然后就变成了 Gunicorn。</p>

<h3 id="四hup">四、HUP</h3>

<p>本来还想讨论一下让 <code class="highlighter-rouge">HUP</code> 信号能够重载(reload)进程的事情，因为这里有个问题是违背了 Docker 单进程容器的规则，我们必然需要让一号进程运行一个进程管理器，它能够处理 <code class="highlighter-rouge">SIGHUB</code> / <code class="highlighter-rouge">SIGINT</code> / …，那么要么我们内存多用 supervisord，要么用轻量级 S6 之类的东西。</p>

<p>但是这样真的好吗？</p>

<p>不想写了，就这样吧。</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">小生境</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jschwinger23
            
            </li>
            
            <li><a href="mailto:greyschwinger@gmail.com">greyschwinger@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jschwinger23"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jschwinger23</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Live to tell
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
