<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="alternate" type="application/rss+xml" title="小生境" href="/feed.xml">
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">小生境</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Turtle in the Shell</h1>
    <p class="post-meta">
      <time datetime="2019-02-09T00:00:00+08:00" itemprop="datePublished">
        
        2019-02-09
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>For my ex whose WeChat name was TurtleShell(乌龟壳).</p>
</blockquote>

<p>上一篇<a href="https://jschwinger23.github.io/2018/02/23/Ghost-in-the-Shell.html">文章</a>是按照<code class="highlighter-rouge">解决问题(Cookbook)</code>的方式来组织文章结构, 这篇文章将采用<code class="highlighter-rouge">技术细节(Guide)</code>的方式来组织.</p>

<p>老规矩:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bash --version
GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin17)
Copyright (C) 2007 Free Software Foundation, Inc.
</code></pre></div></div>

<p>BTW, bash 上个月已经进化到 5.0, 少年们要不要来一发.</p>

<hr />

<h1 id="1-command-substitution"><strong>1. Command Substitution</strong></h1>

<p>相信大家一定非常熟悉了, 两个形式:</p>

<ol>
  <li>`<code class="highlighter-rouge">cmd</code>`, 但是 backquotes 的问题是不能嵌套, 所以我之前都用另一种形式.</li>
  <li><code class="highlighter-rouge">$(cmd)</code>, 虽然可以嵌套, 但是也有一些其他问题, 所以我现在尽量用 Process Substitution.</li>
</ol>

<h4 id="11-比方说"><strong>1.1 比方说</strong></h4>

<p>我们第一次 git push 一个新的 remote 分支的时候总是需要完整输入分支名字:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push -u origin &lt;branch-name&gt;
</code></pre></div></div>

<p>使用 Command Substitution 我们可以避免手动输入:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push -u origin $(git rev-parse --abbrev-ref HEAD)
</code></pre></div></div>

<p>又比如, 使用 <a href="https://github.com/pyenv/pyenv">pyenv</a> 的时候偶尔需要查看源文件, 那么:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi $(pyenv which ipython)
</code></pre></div></div>

<p>就可以查看 IPython 的 entrypoint 源码.</p>

<p>或者我们要遍历一个文件的每一行, 如果每一行的数据里没有空格, 那么可以简单地来:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for line in $(cat file.txt); do echo "-&gt; $line"; done
</code></pre></div></div>

<h4 id="12-坑"><strong>1.2 坑</strong></h4>

<p>然而坑是非常多的!</p>

<p><strong>1.2.1 <code class="highlighter-rouge">\0</code> 会被移除!</strong></p>

<p>简直可以说是日了狗了.</p>

<p>比如说我们要处理 <code class="highlighter-rouge">find -print0</code> 的结果:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(IFS=$'\0' &amp;&amp; for file in $(find . -name '*.md' -print0); do echo "-&gt; $file"; done)
</code></pre></div></div>

<p>是不 work 的, 输出的结果所有的文件在一行被打印出来, <code class="highlighter-rouge">IFS=$'\0'</code> 设置没有问题, 问题是出在 <code class="highlighter-rouge">$(find)</code> 输出的结果把 <code class="highlighter-rouge">\0</code> 删掉了..</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># bash 的坑很多, 为了证明是 Command Substitution 的锅而不是 IFS 和 echo 的锅, 我运行了下面三行代码:

# 首先证明 `echo` 能够打印 `\0` 的 IFS: 
(IFS=$'\0' &amp;&amp; od -a &lt;(echo $IFS))
# output: 0000000   nl

# 再证明 echo Command Substitution 吃掉了 `\0` 
od -a &lt;(echo $(find . -name '*.md' -print0))
# output: 0000000    .   /   b   .   m   d   .   /   a   .   m   d  nl

# 最后再看 Process Substitution: 
od -a &lt;(find . -name '*.md' -print0)
# output: 0000000    .   /   b   .   m   d nul   .   /   a   .   m   d nul

# 后者多出的那个 `nul` 说明了一切.
</code></pre></div></div>

<p>所以如果文件中没有 <code class="highlighter-rouge">\n</code> 的话只能:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(IFS=$'\n' &amp;&amp; for file in $(find . -name '*.md'); do echo "-&gt; $file"; done)
</code></pre></div></div>

<p><em>TIPS: 我用了一对圆括号把整个命令包起来是为了使用 subshell, 这样的话修改 IFS 不会污染当前 bash.</em></p>

<p><strong>1.2.2 <code class="highlighter-rouge">echo</code> raw Command Substitution 会把 <code class="highlighter-rouge">\n</code> 替换为空格</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo $(ls -l)
</code></pre></div></div>

<p>输出</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>total 8 -rw-r--r-- 1 whoami 1032302077 0 Feb 9 18:39 a.md -rw-r--r-- 1 whoami 1032302077 0 Feb 9 18:39 b.md -rw-r--r-- 1 whoami 1032302077 366 Feb 4 18:09 delimit.txt
</code></pre></div></div>

<p>所有结果都在一行, 可以说非常不高兴了.</p>

<p>Here String 也有同样的问题:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while read -d $'\n' -r line; do echo "-&gt; $line"; done &lt;&lt;&lt; $(find .)
</code></pre></div></div>

<p>打印出来所有文件又在一行.</p>

<p>但是 Here Document 不会有问题:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ while read -d $'\n' -r line; do echo "-&gt; $line"; done &lt;&lt;!
&gt; $(find .)
&gt; !
</code></pre></div></div>

<p>每个文件都是单独打印.</p>

<p>所以如果使用 Command Substitution 和 echo / Here String 的时候要记得使用 partial quote:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "$(ls -l)"
while read -d $'\n' -r line; do echo "-&gt; $line"; done &lt;&lt;&lt; "$(find .)"
</code></pre></div></div>

<p>但是 partial quote 的问题是会破坏 word splitting, 也就是说不会使用 IFS 切词, 这就很痛苦了:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for file in "$(find .)"; do echo "-&gt; $file"; done
</code></pre></div></div>

<p>会变成一坨打印出来就是这个原因.</p>

<p>妈的简直太傻逼, 加引号也不行, 不加引号也不行, 所以只要涉及到特殊字符我根本不考虑 Command Substitution, 只用 Process Substitution.</p>

<p><em>TIPS: 我使用 <code class="highlighter-rouge">!</code> 而不是通常的 <code class="highlighter-rouge">EOF</code> 作为 Here Document 的 delimit, 其实在绝大多数情况是完全没有问题的, 能够很好节省键盘.</em></p>

<hr />

<h1 id="2-process-substitution"><strong>2. Process Substitution</strong></h1>

<p>两个用法:</p>
<ol>
  <li><code class="highlighter-rouge">cmd1 &lt;(cmd2)</code>, 可粗糙视为 <code class="highlighter-rouge">exec N&lt;&gt;$(mktemp); cmd2 &gt;&amp;N | cmd1 /dev/fd/N &amp;&amp; exec N&gt;&amp;-</code></li>
  <li><code class="highlighter-rouge">cmd1 &gt;(cmd2)</code>, 可粗糙视为 <code class="highlighter-rouge">exec N&lt;&gt;$(mktemp); cmd2 &lt;&amp;N | cmd1 /dev/fd/N &amp;&amp; exec N&gt;&amp;-</code></li>
</ol>

<p>那么它的好处在于:</p>
<ol>
  <li>如果 <code class="highlighter-rouge">cmd1</code> 只接受文件名, 那么 Process Substitution 简直丝滑, 因为 <code class="highlighter-rouge">&lt;(cmd2)</code> 可视为一个文件;</li>
  <li>如果 <code class="highlighter-rouge">cmd1</code> 接受多个参数, 那么 Process Substitution 避免了管道只能使用 <code class="highlighter-rouge">/dev/fd/0</code> 的捉襟见肘;</li>
  <li>如果依赖 <code class="highlighter-rouge">cmd1</code> 的副作用, 那么 Process Substitution 避免了管道时的 IPC;</li>
  <li>如果 <code class="highlighter-rouge">cmd2</code> 的结果有奇怪的字符以及 <code class="highlighter-rouge">cmd1</code> 依赖 <code class="highlighter-rouge">IFS</code> 做事情, 那么 Process Substitution 能够避免 Command Substitution 与 partial quote 的各种恶心细节.</li>
</ol>

<h4 id="21-直接上栗子"><strong>2.1 直接上栗子</strong></h4>

<p><strong>2.1.1 只接受文件</strong></p>

<p>比如刚才的 <code class="highlighter-rouge">od</code> 命令, BSD od(1) 只接受文件参数而不是接受标准输入, 不过这根本不是问题, 我们可以:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkfifo /tmp/fifo
find . -print0 &gt;/tmp/fifo | od -a /tmp/fifo
rm /tmp/fifo
</code></pre></div></div>

<p>简直和吃屎没区别.</p>

<p><em>TIPS: <code class="highlighter-rouge">find . -print0 | od -a /dev/fd/0</code> 是不行的, 因为 <code class="highlighter-rouge">od</code> 强行关闭了 <code class="highlighter-rouge">/dev/fd/0</code></em></p>

<p>所以我们用 Process Substitution:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>od -a &lt;(find . -print0)
</code></pre></div></div>

<p>非常干净.</p>

<p>再说一个我常用的, 解码系统粘贴板的 base64 数据再粘贴回粘贴板, 同时打印出来:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># macOS ONLY
base64 -i &lt;(pbpaste) | tee &gt;(pbcopy) | cat
</code></pre></div></div>

<p><strong>2.1.2 接受多个命令的标准输出</strong></p>

<p>再来看下使用 vimdiff 查看 git 历史版本的文件 diff, 我们可以使用 <code class="highlighter-rouge">vimdiff</code> 提供的 <code class="highlighter-rouge">-</code> 从 STDIN 读取:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cat-file -p &lt;commit1&gt;:&lt;filename&gt; | vimdiff - filename
</code></pre></div></div>

<p>或者是直接使用 <code class="highlighter-rouge">/dev/fd/0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git cat-file -p &lt;commit1&gt;:&lt;filename&gt; | vimdiff /dev/fd/0 filename
</code></pre></div></div>

<p>然而如果命令强行关闭了 <code class="highlighter-rouge">/dev/fd/0</code> (如 <code class="highlighter-rouge">od</code>), 或者两个参数都是从其他命令的 STDOUT 里得到的, Process Substitution 就是唯一的选择了:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vimdiff &lt;(git cat-file -p &lt;commit1&gt;:&lt;filename&gt;) &lt;(git cat-file -p &lt;commit2&gt;:&lt;filename&gt;)
</code></pre></div></div>

<p>得到的效果不比专业 IDE 的 VCS diff 差.</p>

<p>又或者我们写了一个 Python 脚本, 它目前只能把 <code class="highlighter-rouge">sys.argv[1:]</code> 当做文件读取, 但是我们想利用管道什么的把其他命令的输出塞给它去运行, 那么不需要改一行代码, 使用 Process Substitution 就是醉猴的!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./script.py &lt;(cmd1 | cmd2) &lt;(cmd3) | cmd4
</code></pre></div></div>

<p>还有我经常使用的 <code class="highlighter-rouge">comm</code> 命令去重也是极其好用:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>comm -23 &lt;(find $DIR -type f | sort) &lt;(git ls-tree $COMMIT --name-only -r | grep  $DIR | sort)
</code></pre></div></div>

<p>这句命令列出了 workspace <code class="highlighter-rouge">$DIR</code> 目录下与 <code class="highlighter-rouge">$COMMIT</code> 提交的 <code class="highlighter-rouge">$DIR</code> 目录的文件差集.</p>

<p>虽然可以直接 <code class="highlighter-rouge">git diff --name-only HEAD $COMMIT | grep $DIR</code>, 但是表达的语义是不同的, 一个是差集, 一个 diff, 感受一下.</p>

<p><strong>2.1.3 依赖副作用</strong></p>

<p>比方说, 我要计算所有 txt 里的单词频数, 是不能用管道的:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find . -name '*.txt' -print0 | while read -d '' file; do 
    while read line; do 
        for word in $line; do 
            var=count_$word
            [[ -z "${!var}" ]] &amp;&amp; eval "$var=1" || eval "(($var++))"
        done 
    done &lt;$file 
done

for var in ${!count_*}; do echo "word ${var#count_}: ${!var}"; done
</code></pre></div></div>

<p><em>TIPS: 由于 bash4- 没有 associative array, 只能使用 indirect 来模拟, 其中出现的 <code class="highlighter-rouge">${!var}</code> / <code class="highlighter-rouge">${!var_*}</code> 分别是取间接和列出所有 prefix 为 <code class="highlighter-rouge">$var</code> 的变量名.</em></p>

<p>这样是不行的, 因为管道里的每一个命令都 fork 了新进程, 子进程的变量赋值不会传递给父进程, 除非再处心积虑地 IPC.</p>

<p>所以改成 Process Substitution 就迎刃而解了:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while read -d '' file; do 
    while read line; do 
        for word in $line; do 
            var=count_$word
            [[ -z "${!var}" ]] &amp;&amp; eval "$var=1" || eval "(($var++))"
        done 
    done &lt;$file 
done &lt; &lt;(find . -name '*.txt' -print0)

for var in ${!count_*}; do echo "word ${var#count_} frequency: ${!var}"; done
</code></pre></div></div>

<p><em>TIPS: <code class="highlighter-rouge">&lt; &lt;(cmd)</code> 看起来很奇怪, 其实把 <code class="highlighter-rouge">&lt;(cmd)</code> 看成一个文件, 本质就是 block 级别的 IO redirect, like <code class="highlighter-rouge">&lt; /dev/fd/N</code>.</em></p>

<p><strong>2.1.4 涉及特殊字符</strong></p>

<p>尤其是涉及 <code class="highlighter-rouge">\n</code> / <code class="highlighter-rouge">\0</code> 的时候, Command Substitution 的奇怪的潜规则经常让我想打人, 而 Process Substitution 保证了原汁原味的字符传递.</p>

<p>比方说还是要迭代 <code class="highlighter-rouge">find</code> 的结果, 如果文件名不含 <code class="highlighter-rouge">\n</code> 的话我们还可以用 Command Substitution 把 <code class="highlighter-rouge">\n</code> 作为 delimiter 凑合一下, 但是一旦包含的话就完全不行了, 因为 Command Substitution 会吃掉 <code class="highlighter-rouge">find -print0</code> 的 <code class="highlighter-rouge">\0</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 几种错误的代码

(IFS=$'\0' for file in $(find . -print0); do echo $file; done)
# wrong, Command Substitution purges \0

find . -print0 | while read -d '' file; do echo $file; done
# defective, subprocesses spoil side effects

while read -d '' file; do echo $file; done &lt;&lt;&lt; $(echo "$(find . -print0)")
# wrong, Here String and echo pruges \n

$ while IFS= read -r -d '' file; do echo "$file"; done &lt;&lt;!
&gt; $(find . -print0)
&gt; !
# wrong, Here Document purges \0
</code></pre></div></div>

<p>这时候才真正体现出 Process Substitution 的优越性:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while IFS= read -r -d '' file; do echo $file; done &lt; &lt;(find . -print0)
</code></pre></div></div>

<hr />
<h1 id="3-vim"><strong>3. Vim</strong></h1>

<p>Vim 的强大绝不仅仅表现在一个交互式编辑器, 要知道它的前身可是 ex 和 ed, 不要忘了 sed 就是 stream ed, Vim 作为一个非交互的命令行工具也极其强大.</p>

<p>从下面几个方面解读一下:</p>

<h4 id="31-匹配闭合括号"><strong>3.1 匹配闭合括号</strong></h4>

<p>由于 <code class="highlighter-rouge">GNU/grep</code> 不能处理多行, <code class="highlighter-rouge">awk</code> 正则又不支持递归正则, 所以 Vim 当仁不让地站了出来.</p>

<p>比如要抠出一个 JSON 里 key 为某个值的 value, 已知 value 是 list:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim -es +'g/PAT/norm n%"ay%' +'redir&gt;&gt;/dev/stdout|echon @a' +qa $filename
</code></pre></div></div>

<p>简单解释一下:</p>

<ol>
  <li><code class="highlighter-rouge">-es</code> 分别开启 ex mode 和 silent mode, <code class="highlighter-rouge">+</code> 后面跟 ex command</li>
  <li><code class="highlighter-rouge">g/PAT/norm n%"ay%</code> 是标准的 <code class="highlighter-rouge">global</code> 命令: <code class="highlighter-rouge">g/pattern/command</code></li>
  <li><code class="highlighter-rouge">norm n%"ay%</code> 是使用 normal mode, <code class="highlighter-rouge">n</code> 让光标移动到匹配的模式上, <code class="highlighter-rouge">%</code> 跳到下一个闭合的 <code class="highlighter-rouge">]</code> 上, 然后 <code class="highlighter-rouge">"ay%</code> 把匹配的 <code class="highlighter-rouge">[</code> 之间的内容复制到 <code class="highlighter-rouge">a</code> 寄存器</li>
  <li><code class="highlighter-rouge">redir&gt;&gt;/dev/stdout|echon @a</code> 把 ex command 的输出重定向为标准输出, 然后打印 <code class="highlighter-rouge">a</code> 寄存器</li>
</ol>

<p>我们来简单构造数据:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "adsfraud_main_test_sg": [
    {
      "addr": "10.65.136.28:31866", 
      "host": "10.65.136.28", 
      "port": 31866, 
      "re_registered_times": [], 
      "registered_time": 1542740589
    }
  ], 
  "amp_render_test_id": [
    {
      "addr": "10.65.136.135:31008", 
      "host": "10.65.136.135", 
      "lb_port": null, 
      "port": 31008, 
      "re_registered_times": [], 
      "registered_time": 1542536853
    }
  ]
}
</code></pre></div></div>

<p>这是我们服务发现的 JSON 格式, 如果不用 Vim 大法, 那么只能 <code class="highlighter-rouge">grep -A20</code> 粗略列出来, 非常不智能.</p>

<p>运行一下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim -es  +'g/amp_render_test_id/norm n%"ay%' +'redir&gt;&gt;/dev/stdout|echon @a' +qa s.json
# output:
#                       [
#    {
#      "addr": "10.65.136.135:31008",
#      "host": "10.65.136.135",
#      "lb_port": null,
#      "port": 31008,
#      "re_registered_times": [],
#      "registered_time": 1542536853
#    }
#  ]
</code></pre></div></div>

<p>要注意一个常见的错误:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim -es +'g/PAT/.;/]/p' +qa
</code></pre></div></div>

<p>是不行的, 因为 <code class="highlighter-rouge">/]/</code> 这个模式只能匹配到下一个 <code class="highlighter-rouge">]</code>, 数据一旦嵌套就扑街, 比如上面的数据都不行. 我们必须依赖 <code class="highlighter-rouge">%</code>.</p>

<p>此外, <code class="highlighter-rouge">g/pattern/{range}p</code> 只能打印出选出的行, 而不是 <code class="highlighter-rouge">[]</code> 内部的内容. 考虑以下的数据:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ "adsfraud_main_test_sg": [ { "addr": "10.65.136.28:31866", "host": "10.65.136.28", "port": 31866, "re_registered_times": [], "registered_time": 1542740589 } ], "amp_render_test_id": [ { "addr": "10.65.136.135:31008", "host": "10.65.136.135", "lb_port": null, "port": 31008, "re_registered_times": [], "registered_time": 1542536853 } ] }
</code></pre></div></div>

<p>其实和上面的数据内容一样, 只是这次没有格式化, 我们的代码依然可以正确工作, 这是超越了 <code class="highlighter-rouge">global</code> 命令的!</p>

<h4 id="32-处理段落"><strong>3.2 处理段落</strong></h4>

<p>段落的定义是以 <code class="highlighter-rouge">\n\n</code> 分隔的文本, 比如上次有个需求是提取出一个 yaml 文件中所有类型是 cronjob 的并且每天运行的任务的 cmd，yaml 文件长这样：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>job1:
    cmd: job1
    schedule: "0 18 * * *"
    kind: cronjob

job2:
    kind: cronjob
    cmd: job2
    schedule: "50 18 * * *"

job3:
    kind: daemon
    cmd: ./manage.py corpus_patch_es
</code></pre></div></div>

<p>如果是 awk 的话就要 <code class="highlighter-rouge">awk -F$'\n' RS=</code> 然后以一大坨数据来处理, awk 的切列本领完全没有用武之地, 就很不划算.</p>

<p>看下 Vim 怎么做:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim -es  +'g/cronjob/exe "norm {:/cmd/p\&lt;Cr&gt;"' +qa j.yaml
</code></pre></div></div>

<p>简单解释下:</p>

<ol>
  <li><code class="highlighter-rouge">exe "norm {:/cmd/p\&lt;Cr&gt;"</code>: 如果 <code class="highlighter-rouge">norm</code> 命令中包含 <code class="highlighter-rouge">&lt;Cr&gt;</code> / <code class="highlighter-rouge">&lt;Esc&gt;</code> 之类的东西, 那么需要用 <code class="highlighter-rouge">exe "norm"</code> 的方式执行</li>
  <li><code class="highlighter-rouge">{:/cmd/p\&lt;Cr&gt;</code>, <code class="highlighter-rouge">{</code> 先回跳到上一个 <code class="highlighter-rouge">\n\n</code>, 再 <code class="highlighter-rouge">:/cmd/p</code> 向后搜索并打印, <code class="highlighter-rouge">\&lt;Cr&gt;</code> 是回车</li>
  <li>在 <code class="highlighter-rouge">-es</code> 模式下 <code class="highlighter-rouge">p</code> 命令默认打印到 STDOUD, 所以不需要第一个例子里的重定向, 那时我们用了 <code class="highlighter-rouge">echon</code> 而不是 <code class="highlighter-rouge">p</code></li>
</ol>

<p>你会发现这里的逻辑非常简单, 一切在 Vim 里怎么操作, 你就写下来就可以了, 换成其他任何工具都不可能有这样流畅的体验.</p>

<h4 id="33-批修改"><strong>3.3 批修改</strong></h4>

<p>那就更加是 Vim 的拿手好戏了.</p>

<p>首先 diss 垃圾 sed, Vim 命令简单又好:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim +'s/PAT/REPLACE/g' +xa $FILE
</code></pre></div></div>

<p>为什么说更好, 是因为 Vim 所支持的模式简直比肩 PCRE, lookaround, anchor, atomic group, backref, conservative, 除了递归什么都有, 再加上活学活用等号寄存器, 简直无敌.</p>

<p>来看下 NUS 数据库第一次作业里的一道简单题目, 修改一个 csv 文件, 把符合模式的行的第 7 列数字扩大 1.1 倍:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim +'g/PAT/s/\v([^,]+,){6}\zs[^,]+/\=submatch(0)*1.1/' +xa $FILE
</code></pre></div></div>

<p>简单解释下:</p>

<ol>
  <li><code class="highlighter-rouge">s/PAT/REP/</code> 是 substitute 替换命令</li>
  <li><code class="highlighter-rouge">\v([^,]+,){6}\zs[^,]+</code>, <code class="highlighter-rouge">\v</code> 开启 very magic 模式, <code class="highlighter-rouge">([^,]+,){6}</code> 匹配前 6 列, <code class="highlighter-rouge">\zs</code> 类似环视, 相当于把之前的模式放入 <code class="highlighter-rouge">(?&lt;=PAT)</code> 里, 最后 <code class="highlighter-rouge">[^,]+</code> 匹配第 7 列</li>
  <li><code class="highlighter-rouge">\=submatch(0)*1.1</code>, 等号寄存器可以直接用来计算, 所以直接扩大就可以了</li>
</ol>

<p>也非常直观, 不觉得有任何的困难和别扭的地方, 每个语义都恰到好处.</p>

<hr />
<h1 id="4-其它工具"><strong>4. 其它工具</strong></h1>

<h4 id="41-sed"><strong>4.1 sed</strong></h4>

<p>实际上 sed 已经基本上凉了, 因为讲道理, 大部分正常的机器都会有 Perl5, 那么 sed 的替换功能将完全被 Perl 替换, 并且更加强大. 我们可是在用 PCRE 而不是 sed 那种垃圾 ERE!</p>

<p>比如随手从我的 <code class="highlighter-rouge">~/.history</code> 里找一个 sed:</p>

<p>额没找到, 很久不用了, 那就从书上抄一个:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sed -i 's/\b[0-9]\{3\}\b/NUMBER/g' sed_data.txt
</code></pre></div></div>

<p>这一堆垃圾 escape 真的没人想吐吗? 看看 Perl5:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>perl -pie 's/\b\d{3}\b/NUMBER/g' sed_data.txt
</code></pre></div></div>

<p>根本不需要死记硬背 ERE 哪些是元字符好吗, 那种愚蠢的东西就应该直接烧掉.</p>

<h4 id="42-awk"><strong>4.2 awk</strong></h4>

<p>awk 唯一的用途就变成了在多列的时候很好用, 模式是这样的:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd | awk '$1 ~ /PAT1/ &amp;&amp; ! /PAT2/ {print $5}' | cmd
</code></pre></div></div>

<p>够了, 不要在 awk 里做奇怪的事情, 什么 getline, 什么 gsub, 行了行了, 再不闭嘴就拉黑.</p>

<h4 id="43-grep"><strong>4.3 grep</strong></h4>

<p>至少, 你要 <code class="highlighter-rouge">brew install grep --with-default-names</code>.</p>

<p>其次, 你也应该 <code class="highlighter-rouge">brew install pcre</code>.</p>

<p>然后使用 <code class="highlighter-rouge">pcregrep</code>, 愉快地使用 atomic group 和递归正则有什么不好. 哦不对,  <code class="highlighter-rouge">pcregrep</code> 和 <code class="highlighter-rouge">grep -P</code> 最大区别是 <code class="highlighter-rouge">pcregrep -M</code> 的多行模式简直就是神器.</p>

<p>我们来看上面 Vim 所解决的两个实例.</p>

<p><strong>4.3.1 匹配闭合括号</strong></p>

<p>不想写正则抠 JSON… 因为写出来是这样的:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/
(?(DEFINE)
 (?&lt;number&gt;   -? (?= [1-9]|0(?!\d) ) \d+ (\.\d+)? ([eE] [+-]? \d+)? )    
 (?&lt;boolean&gt;   true | false | null )
 (?&lt;string&gt;    " ([^"\\\\]* | \\\\ ["\\\\bfnrt\/] | \\\\ u [0-9a-f]{4} )* " )
 (?&lt;array&gt;     \[  (?:  (?&amp;json)  (?: , (?&amp;json)  )*  )?  \s* \] )
 (?&lt;pair&gt;      \s* (?&amp;string) \s* : (?&amp;json)  )
 (?&lt;object&gt;    \{  (?:  (?&amp;pair)  (?: , (?&amp;pair)  )*  )?  \s* \} )
 (?&lt;json&gt;   \s* (?: (?&amp;number) | (?&amp;boolean) | (?&amp;string) | (?&amp;array) | (?&amp;object) ) \s* )
)
\A (?&amp;json) \Z
/six   
</code></pre></div></div>

<p>我看和吃屎也没啥区别了.</p>

<p><strong>4.3.2 面向段落</strong></p>

<p>这个还好:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pcregrep -M '(?s)(?&lt;=\n\n|\A).+?cronjob.+?(?=\n\n|\Z)' j.yaml | pcregrep -o1 'cmd:\s*([^\n]+)'
</code></pre></div></div>

<p>emmm, 然而我还是更喜欢 Vim 的做法.</p>

<h4 id="44-here-string"><strong>4.4 Here String</strong></h4>

<p>绝对不应该忘记 Here String, 尤其应该意识到它和 Process Substitution 是互补的.</p>

<p>我们将面临以下几种情况:</p>

<ol>
  <li>命令只接受文件, 但是输入来自其他命令的输出.</li>
  <li>命令只接受文件, 但是输入来自变量.</li>
  <li>命令只接受变量, 但是输入来自其他命令的输出.</li>
  <li>命令只接受标准输入, 但是输入来自变量或其他命令的输出.</li>
</ol>

<p>第一种情况, 我们有 Process Substitution.</p>

<p>第二种情况也很常见, 比如迭代的时候. 我们可以 <code class="highlighter-rouge">echo</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while read var; do cmd &lt;(echo "var"); done
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">echo</code> 会忠实打印 <code class="highlighter-rouge">\n</code> / <code class="highlighter-rouge">\0</code> / <code class="highlighter-rouge">\t</code>, 所以应该不会有太大问题, 只是不要忘了 partial quote.</p>

<p>第三种情况, 我们有 Command Substitution.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd1 $(cmd2)
</code></pre></div></div>

<p>一定要注意 word splitting 的细节, 不引用会用 <code class="highlighter-rouge">IFS</code> 切词, 反之不会.</p>

<p>第四种情况, 我们有 Here String.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd &lt;&lt;&lt; $var
cmd1 &lt;&lt;&lt; $(cmd2)
</code></pre></div></div>

<p>一定要注意这里的坑是 Command Substitution 会杀掉 <code class="highlighter-rouge">\0</code>, 而 <code class="highlighter-rouge">&lt;&lt;&lt;</code> 又会把 <code class="highlighter-rouge">\n</code> 换成空格, 除非我们把 Command Substitution 引用起来. 但是引用的后果是破坏切词, 真的很恶劣了!</p>

<p>所以如果真的有特殊字符不能搞定, 第四种情况恐怕还是要用 Process Substitution 绕一圈:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(read -r var; cmd $var) &lt; &lt;(echo "$var")
(read -r var; cmd1 $var) &lt; &lt;(cmd2)
</code></pre></div></div>

<p>但是除此之外, Here String 还经常被我用来能够快速修改命令参数.</p>

<p>比如我经常用 <code class="highlighter-rouge"><span class="gh">diff &lt;(git cat-file -p &lt;commit1&gt;:&lt;filename&gt;) &lt;(git cat-file -p &lt;commit2&gt;:&lt;filename&gt;)</span></code> 这个命令, 但是每次都要移动光标去修改 <code class="highlighter-rouge">commit</code> 和 <code class="highlighter-rouge">filename</code> 就很烦, 所以我把它改写成:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ read commit1 commit2 filename; diff &lt;(git cat-file -p $commit1:$filename) &lt;(git cat-file -p $commit2:$filename) ; } &lt;&lt;&lt; "HEAD HEAD^ path/to/file"
</code></pre></div></div>

<p>这样每次通过 <a href="https://github.com/dvorka/hstr">hstr</a> 翻出来之后直接加上最后三个参数就 okay.</p>

<p>当然如果你写个函数也是可以的, 但是函数的问题是不方便复制, 而我倾向于总是写完整的命令, 便于复制和复用. 同样的理由我不使用 <code class="highlighter-rouge">!!</code> 之类的东西.</p>

<hr />

<h1 id="5-结论"><strong>5. 结论</strong></h1>

<p>结论当然是 Bash 大法吼啊! Bash 真是太爽啦! Better than fucking boys!</p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">小生境</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              jschwinger23
            
            </li>
            
            <li><a href="mailto:greyschwinger@gmail.com">greyschwinger@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jschwinger23"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jschwinger23</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Live to tell
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
