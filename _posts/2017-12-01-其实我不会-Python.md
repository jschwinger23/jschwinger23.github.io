---
layout: post
---

其实我不会 Python。

比如我有个需求是能够通过基类拿到子类的列表，比如是这样的：

```python
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(A.subclasses)
# expected: [<class '__main__.B'>, <class '__main__.C'>]
```

然后我发现 `__subclasses__` 只能拿到一级继承关系的子类：

> Each new-style class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive.

(by https://docs.python.org/release/2.6.4/library/stdtypes.html#class.\_\_subclasses\_\_)

```
print(A.__subclasses__())
# output: [<class '__main__.B'>]
```

所以眼下我有几个可行的做法：

1. 写一个装饰器，对子类进行 register。
2. 递归查找 `__subclasses__`。
3. 在元类上做一些手脚。
4. 在 `__init_subclass__` 上做一些手脚。

方案一显然太傻比了，继承关系就是很 explicit 的关系了，居然还要再去手动注册。

方案二显然太傻比了，不要在 Python 里用递归除非是算法面试。

方案三显然太傻比了，写出元类还打不打算让别人维护了。

所以只剩下方案四了，虽然也只是比元类稍好一丢丢。

所以应该怎么写呢。

```python
class A:
    subclasses = []
    def __init_subclass__(cls, *args, **kws):
        super().__init_subclass__(**kws)
        cls.subclasses.append(cls)
```

写两个类试一下:

```python
class B(A):
    pass

class C(B):
    pass

print(A.subclasses)
# output: [<class '__main__.B'>, <class '__main__.C'>]
```

works fine!

然后我发现有很多类都有这种需求，我决定写个装饰器，用法是这样的：

```python
@record_subclasses
class A:
    pass

class B:
    pass

class C
    pass

print(A.subclasses)
# output: [<class '__main__.B'>, <class '__main__.C'>]
```

好，动手！

```python
def record_subclasses(klass):
    def __init_subclass__(cls, *args, **kws):
        super().__init_subclass__(**kws)
        cls.subclasses.append(cls)

    klass.subclasses = []
    klass.__init_subclass__ = __init_subclass__
    return klass

@record_subclasses
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(A.subclasses)
```

然而运行起来的时候报错了lol

```
# output
TypeError: __init_subclass__() missing 1 required positional argument: 'cls'
```

出错的原因是 `__init_subclass__` 是一个隐式类方法，a.k.a 我们必须用 `classmethod` 给它包起来。

```python
def record_subclasses(klass):
    @classmethod
    def __init_subclass__(cls, *args, **kws):
        super().__init_subclass__(**kws)
        cls.subclasses.append(cls)

    klass.subclasses = []
    klass.__init_subclass__ = __init_subclass__
    return klass

@record_subclasses
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(A.subclasses)
```

looks good，然而依然报错。

```
# output
RuntimeError: super(): __class__ cell not found
```

因为新式 `super` 的参数其实是通过 `__class__` 与 `<firstarg>` 隐式传入的，而 Python 的变量查找又是词法作用域规则，因此在 runtime 时找不到 `__class__` 变量。

> The new syntax: `super()` is equivalent to: `super(__class__, <firstarg>)` where `__class__` is the class that the method was defined in, and `<firstarg>` is the first parameter of the method (normally self for instance methods, and cls for class methods). 

(by https://www.python.org/dev/peps/pep-3135/#specification)

所以 fallback 到 pre-[PEP 3135](https://www.python.org/dev/peps/pep-3135/) 的 super，应该写成：

```python
def record_subclasses(klass):
    @classmethod
    def __init_subclass__(cls, *args, **kws):
        super(cls).__init_subclass__(**kws)
        cls.subclasses.append(cls)

    klass.subclasses = []
    klass.__init_subclass__ = __init_subclass__
    return klass

@record_subclasses
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(A.subclasses)
```

终于，这下**看上去**正常了。

```
# output
[<class '__main__.B'>, <class '__main__.C'>]
```

但是还是有问题。

要弄清楚这里的问题的话必须完成搞清楚 `super` 的用法，which 是严重 undocumented 的。所以我打算自己写一个 `super`。

首先我要做的事情是定义**方法**类型，which 是个描述符。

```python
class Method:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kws):
        return self.func(*args, **kws)

    def __get__(self, instance, owner):
        raise NotImplementedError

class InstanceMethod(Method):
    def __get__(self, instance, owner):
        # bound method
        if instance:
            partial = lambda *args, **kws: self(instance, *args, **kws)
            return __class__(partial)

        # unbound method
        else:
            return self
```

我们来验证一下绑定方法、非绑定方法：

```python
def a(self):
    print(self)

class A:
    @InstanceMethod
    def a(self):
        return self

print(A.a)
# output: <__main__.InstanceMethod at 0x10e12f6a0>

print(A.a())
# output: TypeError: a() missing 1 required positional argument: 'self'

a = A()

print(a.a())
# output: <__main__.A object at 0x10e10ceb8>

print(A.a(a))
# output: <__main__.A object at 0x10e10ceb8>
```

然后我要写个 `classmethod`。 

```python
class ClassMethod(Method):
    def __get__(self, instance, owner):
        if owner:
            partial = lambda *args, **kws: self.func(owner, *args, **kws)
            return ClassMethod(partial)

        else:
            return self
```

试一下：

```python
A.a()
# output: __main__.A

A().a()
# output: __main__.A
```

然后实现一个 property：

```python
class Property:
    def __init__(self, func):
        self.func = func
        self.setter_func = None

    def __get__(self, instance, owner):
        if instance:
            return self.func(instance)

        else:
            return self

    def __set__(self, instance, value):
        if not self.setter:
            raise AttributeError("can't set attribute")

        self.setter_func(instance, value)

    def setter(self, func):
        self.setter_func = func
```

不设置 `setter` 时应该报错：

```python
class A:
    @Property
    def a(self):
        return self

a = A()
print(a.a)
# output: <__main__.A object at 0x10e104b70>

a.a = 1
# output: AttributeError: can't set attribute
```

设置后应该会检查：

```python
class A:
    def __init__(self):
        self._a = 0

    @Property
    def a(self):
        return self._a

    @a.setter
    def a_setter(self, value):
        if not isinstance(value, int):
            raise ValueError('property a must be instance of int')
        self._a = value

a = A()
print(a.a)
# output: 0

a.a = 100
print(a.a)
# output: 100

a.a = '100'
# output: ValueError: property a must be instance of int
```

说到 property，我该如何实现一个既是类方法也是属性方法的方法呢？
它看起来应该是这样的：

```python
class A:
    @property
    @classmethod
    def a(cls):
        return cls

print(A.a)
# expected: <class '__main__.A'>
```

然而 `classmethod` 套 `property` 是不 work 的。
正确的做法当然是自己写描述符啊。

```python
class ClassProperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        if owner:
            return self.func(owner)

        else:
            return self

class A:
    @ClassProperty
    def a(cls):
        return cls

print(A.a)
# output: <class '__main__.A'>
```

最后终于到了 super。
先看 docstring:

1. super() -> same as super(\_\_class\_\_, \<first argument\>)
2. super(type) -> unbound super object
3. super(type, obj) -> bound super object; requires isinstance(obj, type)
4. super(type, type2) -> bound super object; requires issubclass(type2, type)

先从第三个开始实现：

```python
from inspect import isclass

class InstanceBoundSuper:
    def __init__(self, type, obj):
        if not isinstance(obj, type):
            raise TypeError('super(type, obj): obj must be an instance of type')

        self.__self_class__ = type
        self.__self__ = obj

    def __getattr__(self, attr):
        mro = self.__self_class__.mro()
        index = mro.index(self.__self_class__)
        for i in range(index, len(mro)):
            klass = mro[i]
            if attr in klass.__dict__:
                raw_method = klass.__dict__[attr]
                return raw_method.__get__(self.__self__)
	raise AttributeError('no attribute %s' %s attr)

def super_(*args):
    if len(args) == 2:
        type, obj = args
	return InstanceBoundSuper(type, obj)
```

思路还是很清晰的，用 `__self_class__` 和 `__self__` 存储，然后用 `mro` 搜索 `__self_class__` 之后的类中第一个在其字典空间中有属性名称的类，然后绑定。
(这里无视了 `super` 搜索非描述符的情况)

然后可以实现第四个功能：

```python
from inspect import isclass

class ClassBoundSuper:
    def __init__(self, type1, type2):
        if not issubclass(type2, type1):
            raise TypeError('super(type1, type2): type2 must be an subclass of type1')

        self.__self_class__ = type1
        self.__self__ = type2

    def __getattr__(self, attr):
        mro = self.__self_class__.mro()
        index = mro.index(self.__self_class__)
        for i in range(index, len(mro)):
            klass = mro[i]
            if attr in klass.__dict__:
                raw_method = klass.__dict__[attr]
                return raw_method.__get__(None, self.__self__)

def super_(*args):
    if len(args) == 2:
        type, obj = args
        if isclass(obj):
            return ClassBoundSuper(type, obj)
        else:
            return InstanceBoundSuper(type, obj)
```
有变化的地方是 `__getattr__` 最后调用 `__get__` 时传入 `owner` 参数而不是 `instance` 参数。

有了这两项实现应该已经可以 cover 绝大部分正常的使用了：

```python
class A:
    def ai(self):
        print(__class__, self)

    @classmethod
    def ac(cls):
        print(__class__, cls)

class B(A):
    pass

b = B()

print(super_(B, b).ai())
# output: <class '__main__.A'> <__main__.B object at 0x10653c7b8>

print(super_(B, B).ac())
# output: <class '__main__.A'> <class '__main__.B'>
```

最后是丧心病狂是功能二。我们要实现的功能应该是这样的：

```python
class A:
    def a(self):
        print(__class__, self)

class B:
    pass

B.parent = super(B)

b = B()
print(b.parent)
# output: <super: __main__.B, <__main__.B at 0x10e0b7c88>>

print(b.parent.a())
# output: <class '__main__.A'> <__main__.B object at 0x10e17a9b0>
```

实现起来应该不会特别复杂。

```python
class UnboundSuper:
    def __init__(self, klass):
        self.klass = klass

    def __get__(self, instance, owner):
        if instance:
            return BoundSuper(owner, instance)
        else:
            return self

def super_(*args):
    if len(args) == 2:
        type, obj = args
        if isclass(obj):
            return ClassBoundSuper(type, obj)
        else:
            return InstanceBoundSuper(type, obj)
    elif len(args) == 1:
        return UnboundSuper(args[0])
```

那么现在再回头看一下当初实现的 `super` 有什么问题。

一开始我们是这样来使用 `super` 的：

```python
def record_subclasses(klass):
    @classmethod
    def __init_subclass__(cls, *args, **kws):
        super(cls).__init_subclass__(**kws)
        cls.subclasses.append(cls)

    klass.subclasses = []
    klass.__init_subclass__ = __init_subclass__
    return klass
```

注意里面 `super(cls).__init_subclass__`，这样的用法是完全错误的。`super(type)` 的用法已经在上文阐述，基本只会作为描述符定义在类的字典空间从而使用基类方法这一用途，正常情况下都应该使用双参数或无参数的 `super` 指定 `从哪个类往上搜索 mro` 和 `绑定哪个对象`。这里没有出现异常的唯一原因是 `__init_subclass__` 是一个特殊方法，`super` 对象继承自 `object` 是有这个方法的，只是什么都不干。如果依赖 `mro` 上游的某个 `__init_subclass__` 实现，那么这里会出现问题；或者这里不是一个特殊方法，那么会立刻报错 `AttributeError: 'super' object has no attribute`。

可以回头看看去年的 [听说你会 Python](http://manjusaka.itscoder.com/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/)，其中有最后一道题是希望用元类为类添加 `__new__` 方法从而变为单例。那里的出错点也是类似，因为 `__new__` 是一个隐式的静态方法：

> \_\_new\_\_() is a static method (special-cased so you need not declare it as such) that takes the class of which an instance was requested as its first argument. 

(by https://docs.python.org/3/reference/datamodel.html#object.\_\_new\_\_)

关于这点连 Fluent Python 都搞错了，书中阐述说 `__new__` 是一个类方法，这是错误的。

就是这样。

经过这一篇博客，我感到自己离 **装逼如风、常伴吾身** 的层次太远了，我要坦白，其实我不会 Python。
